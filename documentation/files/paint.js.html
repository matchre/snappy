<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>paint.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/AlignmentMorph.html">AlignmentMorph</a></li>
            
                <li><a href="../classes/ArgLabelMorph.html">ArgLabelMorph</a></li>
            
                <li><a href="../classes/ArgMorph.html">ArgMorph</a></li>
            
                <li><a href="../classes/ArrowMorph.html">ArrowMorph</a></li>
            
                <li><a href="../classes/BlinkerMorph.html">BlinkerMorph</a></li>
            
                <li><a href="../classes/BlockDialogMorph.html">BlockDialogMorph</a></li>
            
                <li><a href="../classes/BlockEditorMorph.html">BlockEditorMorph</a></li>
            
                <li><a href="../classes/BlockExportDialogMorph.html">BlockExportDialogMorph</a></li>
            
                <li><a href="../classes/BlockHighlightMorph.html">BlockHighlightMorph</a></li>
            
                <li><a href="../classes/BlockImportDialogMorph.html">BlockImportDialogMorph</a></li>
            
                <li><a href="../classes/BlockInputFragmentMorph.html">BlockInputFragmentMorph</a></li>
            
                <li><a href="../classes/BlockLabelFragment.html">BlockLabelFragment</a></li>
            
                <li><a href="../classes/BlockLabelFragmentMorph.html">BlockLabelFragmentMorph</a></li>
            
                <li><a href="../classes/BlockLabelPlaceHolderMorph.html">BlockLabelPlaceHolderMorph</a></li>
            
                <li><a href="../classes/BlockMorph.html">BlockMorph</a></li>
            
                <li><a href="../classes/BooleanSlotMorph.html">BooleanSlotMorph</a></li>
            
                <li><a href="../classes/BouncerMorph.html">BouncerMorph</a></li>
            
                <li><a href="../classes/BoxMorph.html">BoxMorph</a></li>
            
                <li><a href="../classes/CellMorph.html">CellMorph</a></li>
            
                <li><a href="../classes/CircleBoxMorph.html">CircleBoxMorph</a></li>
            
                <li><a href="../classes/Color.html">Color</a></li>
            
                <li><a href="../classes/ColorPaletteMorph.html">ColorPaletteMorph</a></li>
            
                <li><a href="../classes/ColorPickerMorph.html">ColorPickerMorph</a></li>
            
                <li><a href="../classes/ColorSlotMorph.html">ColorSlotMorph</a></li>
            
                <li><a href="../classes/CommandBlockMorph.html">CommandBlockMorph</a></li>
            
                <li><a href="../classes/CommandSlotMorph.html">CommandSlotMorph</a></li>
            
                <li><a href="../classes/CommentMorph.html">CommentMorph</a></li>
            
                <li><a href="../classes/Context.html">Context</a></li>
            
                <li><a href="../classes/Costume.html">Costume</a></li>
            
                <li><a href="../classes/CostumeEditorMorph.html">CostumeEditorMorph</a></li>
            
                <li><a href="../classes/CostumeIconMorph.html">CostumeIconMorph</a></li>
            
                <li><a href="../classes/CSlotMorph.html">CSlotMorph</a></li>
            
                <li><a href="../classes/CursorMorph.html">CursorMorph</a></li>
            
                <li><a href="../classes/CustomBlockDefinition.html">CustomBlockDefinition</a></li>
            
                <li><a href="../classes/CustomCommandBlockMorph.html">CustomCommandBlockMorph</a></li>
            
                <li><a href="../classes/CustomReporterBlockMorph.html">CustomReporterBlockMorph</a></li>
            
                <li><a href="../classes/DialogBoxMorph.html">DialogBoxMorph</a></li>
            
                <li><a href="../classes/FrameMorph.html">FrameMorph</a></li>
            
                <li><a href="../classes/FunctionSlotMorph.html">FunctionSlotMorph</a></li>
            
                <li><a href="../classes/GrayPaletteMorph.html">GrayPaletteMorph</a></li>
            
                <li><a href="../classes/HandleMorph.html">HandleMorph</a></li>
            
                <li><a href="../classes/HandMorph.html">HandMorph</a></li>
            
                <li><a href="../classes/HatBlockMorph.html">HatBlockMorph</a></li>
            
                <li><a href="../classes/IDE_Morph.html">IDE_Morph</a></li>
            
                <li><a href="../classes/InputFieldMorph.html">InputFieldMorph</a></li>
            
                <li><a href="../classes/InputSlotDialogMorph.html">InputSlotDialogMorph</a></li>
            
                <li><a href="../classes/InputSlotMorph.html">InputSlotMorph</a></li>
            
                <li><a href="../classes/InspectorMorph.html">InspectorMorph</a></li>
            
                <li><a href="../classes/JaggedBlockMorph.html">JaggedBlockMorph</a></li>
            
                <li><a href="../classes/JukeboxMorph.html">JukeboxMorph</a></li>
            
                <li><a href="../classes/List.html">List</a></li>
            
                <li><a href="../classes/ListMorph.html">ListMorph</a></li>
            
                <li><a href="../classes/ListWatcherMorph.html">ListWatcherMorph</a></li>
            
                <li><a href="../classes/MenuItemMorph.html">MenuItemMorph</a></li>
            
                <li><a href="../classes/MenuMorph.html">MenuMorph</a></li>
            
                <li><a href="../classes/MouseSensorMorph.html">MouseSensorMorph</a></li>
            
                <li><a href="../classes/MultiArgMorph.html">MultiArgMorph</a></li>
            
                <li><a href="../classes/MyClass.html">MyClass</a></li>
            
                <li><a href="../classes/Node.html">Node</a></li>
            
                <li><a href="../classes/Note.html">Note</a></li>
            
                <li><a href="../classes/PaintCanvasMorph.html">PaintCanvasMorph</a></li>
            
                <li><a href="../classes/PaintEditorMorph.html">PaintEditorMorph</a></li>
            
                <li><a href="../classes/PenMorph.html">PenMorph</a></li>
            
                <li><a href="../classes/Point.html">Point</a></li>
            
                <li><a href="../classes/Process.html">Process</a></li>
            
                <li><a href="../classes/ProjectDialogMorph.html">ProjectDialogMorph</a></li>
            
                <li><a href="../classes/PrototypeHatBlockMorph.html">PrototypeHatBlockMorph</a></li>
            
                <li><a href="../classes/PushButtonMorph.html">PushButtonMorph</a></li>
            
                <li><a href="../classes/ReadStream.html">ReadStream</a></li>
            
                <li><a href="../classes/Rectangle.html">Rectangle</a></li>
            
                <li><a href="../classes/ReporterBlockMorph.html">ReporterBlockMorph</a></li>
            
                <li><a href="../classes/ReporterSlotMorph.html">ReporterSlotMorph</a></li>
            
                <li><a href="../classes/RingCommandSlotMorph.html">RingCommandSlotMorph</a></li>
            
                <li><a href="../classes/RingMorph.html">RingMorph</a></li>
            
                <li><a href="../classes/RingReporterSlotMorph.html">RingReporterSlotMorph</a></li>
            
                <li><a href="../classes/ScriptsMorph.html">ScriptsMorph</a></li>
            
                <li><a href="../classes/ScrollFrameMorph.html">ScrollFrameMorph</a></li>
            
                <li><a href="../classes/ShadowMorph.html">ShadowMorph</a></li>
            
                <li><a href="../classes/SliderButtonMorph.html">SliderButtonMorph</a></li>
            
                <li><a href="../classes/SliderMorph.html">SliderMorph</a></li>
            
                <li><a href="../classes/SnapSerializer.html">SnapSerializer</a></li>
            
                <li><a href="../classes/Sound.html">Sound</a></li>
            
                <li><a href="../classes/SoundIconMorph.html">SoundIconMorph</a></li>
            
                <li><a href="../classes/SpeechBubbleMorph.html">SpeechBubbleMorph</a></li>
            
                <li><a href="../classes/SpriteBubbleMorph.html">SpriteBubbleMorph</a></li>
            
                <li><a href="../classes/SpriteHighlightMorph.html">SpriteHighlightMorph</a></li>
            
                <li><a href="../classes/SpriteMorph.html">SpriteMorph</a></li>
            
                <li><a href="../classes/StageMorph.html">StageMorph</a></li>
            
                <li><a href="../classes/StagePrompterMorph.html">StagePrompterMorph</a></li>
            
                <li><a href="../classes/StringFieldMorph.html">StringFieldMorph</a></li>
            
                <li><a href="../classes/StringMorph.html">StringMorph</a></li>
            
                <li><a href="../classes/SVG_Costume.html">SVG_Costume</a></li>
            
                <li><a href="../classes/SymbolMorph.html">SymbolMorph</a></li>
            
                <li><a href="../classes/SyntaxElementMorph.html">SyntaxElementMorph</a></li>
            
                <li><a href="../classes/TabMorph.html">TabMorph</a></li>
            
                <li><a href="../classes/TemplateSlotMorph.html">TemplateSlotMorph</a></li>
            
                <li><a href="../classes/TextMorph.html">TextMorph</a></li>
            
                <li><a href="../classes/TextSlotMorph.html">TextSlotMorph</a></li>
            
                <li><a href="../classes/ThreadManager.html">ThreadManager</a></li>
            
                <li><a href="../classes/ToggleButtonMorph.html">ToggleButtonMorph</a></li>
            
                <li><a href="../classes/ToggleElementMorph.html">ToggleElementMorph</a></li>
            
                <li><a href="../classes/ToggleMorph.html">ToggleMorph</a></li>
            
                <li><a href="../classes/TriggerMorph.html">TriggerMorph</a></li>
            
                <li><a href="../classes/TurtleIconMorph.html">TurtleIconMorph</a></li>
            
                <li><a href="../classes/UpvarReference.html">UpvarReference</a></li>
            
                <li><a href="../classes/VariableDialogMorph.html">VariableDialogMorph</a></li>
            
                <li><a href="../classes/VariableFrame.html">VariableFrame</a></li>
            
                <li><a href="../classes/WardrobeMorph.html">WardrobeMorph</a></li>
            
                <li><a href="../classes/WatcherMorph.html">WatcherMorph</a></li>
            
                <li><a href="../classes/WorldMorph.html">WorldMorph</a></li>
            
                <li><a href="../classes/XML_Element.html">XML_Element</a></li>
            
                <li><a href="../classes/XML_Serializer.html">XML_Serializer</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: paint.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
    paint.js

    a paint editor for Snap!
    inspired by the Scratch paint editor.
 
    written by Kartik Chandra
    Copyright (C) 2013 by Kartik Chandra
  
    This file is part of Snap!.
 
    Snap! is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as
    published by the Free Software Foundation, either version 3 of
    the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.


    toc
    ---
    the following list shows the order in which all constructors are
    defined. Use this list to locate code in this document:

        PaintEditorMorph
        PaintColorPickerMorph
        PaintCanvasMorph


    credits
    -------
    Nathan Dinsmore contributed a fully working prototype,
    Nathan&#x27;s brilliant flood-fill tool has been more or less
    directly imported into this paint implementation.

    Jens Mönig has contributed icons and bugfixes and says he has probably
    introduced many other bugs in that process. :-)


    revision history
    ----------------
    May 10 - first full release (Kartik)
    May 14 - bugfixes, Snap integration (Jens)
    May 16 - flat design adjustments (Jens)
    July 12 - pipette tool, code formatting adjustments (Jens)
    September 16 - flood fill freeze fix (Kartik)

 */

/*global Point, Rectangle, DialogBoxMorph, fontHeight, AlignmentMorph,
 FrameMorph, PushButtonMorph, Color, SymbolMorph, newCanvas, Morph, TextMorph,
 CostumeIconMorph, IDE_Morph, Costume, SpriteMorph, nop, Image, WardrobeMorph,
 TurtleIconMorph, localize, MenuMorph, InputFieldMorph, SliderMorph,
 ToggleMorph, ToggleButtonMorph, BoxMorph, modules, radians,
 MorphicPreferences, getDocumentPositionOf
 */

// Global stuff ////////////////////////////////////////////////////////

modules.paint = &#x27;2013-September-16&#x27;;

// Declarations

var PaintEditorMorph;
var PaintCanvasMorph;
var PaintColorPickerMorph;

// PaintEditorMorph //////////////////////////
/**
* A complete paint editor
*
* @class PaintEditorMorph
* @constructor
*/
// A complete paint editor

PaintEditorMorph.prototype = new DialogBoxMorph();
PaintEditorMorph.prototype.constructor = PaintEditorMorph;
PaintEditorMorph.uber = DialogBoxMorph.prototype;

PaintEditorMorph.prototype.padding = 10;

function PaintEditorMorph() {
    this.init();
}

PaintEditorMorph.prototype.init = function () {
    // additional properties:
    this.paper = null; // paint canvas
    this.oncancel = null;

    // initialize inherited properties:
    PaintEditorMorph.uber.init.call(this);

    // override inherited properties:
    this.labelString = &quot;Paint Editor&quot;;
    this.createLabel();

    // build contents:
    this.buildContents();
};

PaintEditorMorph.prototype.buildContents = function () {
    var myself = this;

    this.paper = new PaintCanvasMorph(function () {return myself.shift; });
    this.paper.setExtent(new Point(480, 360));

    this.addBody(new AlignmentMorph(&#x27;row&#x27;, this.padding));
    this.controls = new AlignmentMorph(&#x27;column&#x27;, this.padding);
    this.controls.alignment = &#x27;left&#x27;;

    this.edits = new AlignmentMorph(&#x27;row&#x27;, this.padding);
    this.buildEdits();
    this.controls.add(this.edits);

    this.body.color = this.color;

    this.body.add(this.controls);
    this.body.add(this.paper);

    this.toolbox = new BoxMorph();
    this.toolbox.color = SpriteMorph.prototype.paletteColor.lighter(8);
    this.toolbox.borderColor = this.toolbox.color.lighter(40);
    if (MorphicPreferences.isFlat) {
        this.toolbox.edge = 0;
    }

    this.buildToolbox();
    this.controls.add(this.toolbox);

    this.propertiesControls = {
        colorpicker: null,
        penSizeSlider: null,
        penSizeField: null,
        primaryColorButton: null,
        primaryColorViewer: null,
        constrain: null
    };
    this.populatePropertiesMenu();

    this.addButton(&quot;ok&quot;, &quot;OK&quot;);
    this.addButton(&quot;cancel&quot;, &quot;Cancel&quot;);

    this.refreshToolButtons();
    this.fixLayout();
    this.drawNew();
};

PaintEditorMorph.prototype.buildToolbox = function () {
    var tools = {
            brush:
                &quot;Paintbrush tool\n(free draw)&quot;,
            rectangle:
                &quot;Stroked Rectangle\n(shift: square)&quot;,
            circle:
                &quot;Stroked Ellipse\n(shift: circle)&quot;,
            eraser:
                &quot;Eraser tool&quot;,
            crosshairs:
                &quot;Set the rotation center&quot;,

            line:
                &quot;Line tool\n(shift: vertical/horizontal)&quot;,
            rectangleSolid:
                &quot;Filled Rectangle\n(shift: square)&quot;,
            circleSolid:
                &quot;Filled Ellipse\n(shift: circle)&quot;,
            paintbucket:
                &quot;Fill a region&quot;,
            pipette:
                &quot;Pipette tool\n(pick a color anywhere)&quot;
        },
        myself = this,
        left = this.toolbox.left(),
        top = this.toolbox.top(),
        padding = 2,
        inset = 5,
        x = 0,
        y = 0;

    Object.keys(tools).forEach(function (tool) {
        var btn = myself.toolButton(tool, tools[tool]);
        btn.setPosition(new Point(
            left + x,
            top + y
        ));
        x += btn.width() + padding;
        if (tool === &quot;crosshairs&quot;) {
            x = 0;
            y += btn.height() + padding;
            myself.paper.drawcrosshair();
        }
        myself.toolbox[tool] = btn;
        myself.toolbox.add(btn);
    });

    this.toolbox.bounds = this.toolbox.fullBounds().expandBy(inset * 2);
    this.toolbox.drawNew();
};

PaintEditorMorph.prototype.buildEdits = function () {
    var paper = this.paper;

    this.edits.add(this.pushButton(
        &quot;undo&quot;,
        function () {paper.undo(); }
    ));

    this.edits.add(this.pushButton(
        &quot;clear&quot;,
        function () {paper.clearCanvas(); }
    ));
    this.edits.fixLayout();
};

PaintEditorMorph.prototype.openIn = function (world, oldim, oldrc, callback) {
    // Open the editor in a world with an optional image to edit
    this.oldim = oldim;
    this.oldrc = oldrc.copy();
    this.callback = callback || nop;

    this.processKeyUp = function () {
        this.shift = false;
        this.propertiesControls.constrain.refresh();
    };

    this.processKeyDown = function () {
        this.shift = this.world().currentKey === 16;
        this.propertiesControls.constrain.refresh();
    };

    //merge oldim:
    if (this.oldim) {
        this.paper.centermerge(this.oldim, this.paper.paper);
        this.paper.rotationCenter =
            this.oldrc.add(
                new Point(
                    (this.paper.paper.width - this.oldim.width) / 2,
                    (this.paper.paper.height - this.oldim.height) / 2
                )
            );
        this.paper.drawNew();
    }

    this.key = &#x27;paint&#x27;;
    this.popUp(world);
};

PaintEditorMorph.prototype.fixLayout = function () {
    var oldFlag = Morph.prototype.trackChanges;

    this.changed();
    oldFlag = Morph.prototype.trackChanges;
    Morph.prototype.trackChanges = false;

    if (this.paper) {
        this.paper.buildContents();
        this.paper.drawNew();
    }
    if (this.controls) {this.controls.fixLayout(); }
    if (this.body) {this.body.fixLayout(); }
    PaintEditorMorph.uber.fixLayout.call(this);

    Morph.prototype.trackChanges = oldFlag;
    this.changed();
};

PaintEditorMorph.prototype.refreshToolButtons = function () {
    this.toolbox.children.forEach(function (toggle) {
        toggle.refresh();
    });
};

PaintEditorMorph.prototype.ok = function () {
    this.callback(
        this.paper.paper,
        this.paper.rotationCenter
    );
    this.destroy();
};

PaintEditorMorph.prototype.cancel = function () {
    if (this.oncancel) {this.oncancel(); }
    this.destroy();
};

PaintEditorMorph.prototype.populatePropertiesMenu = function () {
    var c = this.controls,
        myself = this,
        pc = this.propertiesControls,
        alpen = new AlignmentMorph(&quot;row&quot;, this.padding);

    pc.primaryColorViewer = new Morph();
    pc.primaryColorViewer.setExtent(new Point(180, 50));
    pc.primaryColorViewer.color = new Color(0, 0, 0);
    pc.colorpicker = new PaintColorPickerMorph(
        new Point(180, 100),
        function (color) {
            var ni = newCanvas(pc.primaryColorViewer.extent()),
                ctx = ni.getContext(&quot;2d&quot;),
                i,
                j;
            myself.paper.settings.primarycolor = color;
            if (color === &quot;transparent&quot;) {
                for (i = 0; i &lt; 180; i += 5) {
                    for (j = 0; j &lt; 15; j += 5) {
                        ctx.fillStyle =
                            ((j + i) / 5) % 2 === 0 ?
                                            &quot;rgba(0, 0, 0, 0.2)&quot; :
                                            &quot;rgba(0, 0, 0, 0.5)&quot;;
                        ctx.fillRect(i, j, 5, 5);

                    }
                }
            } else {
                ctx.fillStyle = color.toString();
                ctx.fillRect(0, 0, 180, 15);
            }
            ctx.strokeStyle = &quot;black&quot;;
            ctx.lineWidth = Math.min(myself.paper.settings.linewidth, 20);
            ctx.beginPath();
            ctx.lineCap = &quot;round&quot;;
            ctx.moveTo(20, 30);
            ctx.lineTo(160, 30);
            ctx.stroke();
            pc.primaryColorViewer.image = ni;
            pc.primaryColorViewer.changed();
        }
    );
    pc.colorpicker.action(new Color(0, 0, 0));

    pc.penSizeSlider = new SliderMorph(0, 20, 5, 5);
    pc.penSizeSlider.orientation = &quot;horizontal&quot;;
    pc.penSizeSlider.setHeight(15);
    pc.penSizeSlider.setWidth(150);
    pc.penSizeSlider.action = function (num) {
        if (pc.penSizeField) {
            pc.penSizeField.setContents(num);
        }
        myself.paper.settings.linewidth = num;
        pc.colorpicker.action(myself.paper.settings.primarycolor);
    };
    pc.penSizeField = new InputFieldMorph(&quot;5&quot;, true, null, false);
    pc.penSizeField.contents().minWidth = 20;
    pc.penSizeField.setWidth(25);
    pc.penSizeField.accept = function () {
        var val = parseFloat(pc.penSizeField.getValue());
        pc.penSizeSlider.value = val;
        pc.penSizeSlider.drawNew();
        pc.penSizeSlider.updateValue();
        this.setContents(val);
        myself.paper.settings.linewidth = val;
        this.world().keyboardReceiver = myself;
        pc.colorpicker.action(myself.paper.settings.primarycolor);
    };
    alpen.add(pc.penSizeSlider);
    alpen.add(pc.penSizeField);
    alpen.color = myself.color;
    alpen.fixLayout();
    pc.penSizeField.drawNew();
    pc.constrain = new ToggleMorph(
        &quot;checkbox&quot;,
        this,
        function () {myself.shift = !myself.shift; },
        &quot;Constrain proportions of shapes?\n(you can also hold shift)&quot;,
        function () {return myself.shift; }
    );
    c.add(pc.colorpicker);
    //c.add(pc.primaryColorButton);
    c.add(pc.primaryColorViewer);
    c.add(new TextMorph(&quot;Brush size&quot;));
    c.add(alpen);
    c.add(pc.constrain);
};

PaintEditorMorph.prototype.toolButton = function (icon, hint) {
    var button, myself = this;

    button = new ToggleButtonMorph(
        null,
        this,
        function () { // action
            myself.paper.currentTool = icon;
            myself.paper.toolChanged(icon);
            myself.refreshToolButtons();
            if (icon === &#x27;pipette&#x27;) {
                myself.getUserColor();
            }
        },
        new SymbolMorph(icon, 18),
        function () {return myself.paper.currentTool === icon; }
    );

    button.hint = hint;
    button.drawNew();
    button.fixLayout();
    return button;
};

PaintEditorMorph.prototype.pushButton = function (title, action, hint) {
    return new PushButtonMorph(
        this,
        action,
        title,
        null,
        hint
    );
};

PaintEditorMorph.prototype.getUserColor = function () {
    var myself = this,
        world = this.world(),
        hand = world.hand,
        posInDocument = getDocumentPositionOf(world.worldCanvas),
        mouseMoveBak = hand.processMouseMove,
        mouseDownBak = hand.processMouseDown,
        mouseUpBak = hand.processMouseUp;

    hand.processMouseMove = function (event) {
        var color;
        hand.setPosition(new Point(
            event.pageX - posInDocument.x,
            event.pageY - posInDocument.y
        ));
        color = world.getGlobalPixelColor(hand.position());
        color.a = 255;
        myself.propertiesControls.colorpicker.action(color);
    };

    hand.processMouseDown = nop;

    hand.processMouseUp = function () {
        myself.paper.currentTool = &#x27;brush&#x27;;
        myself.paper.toolChanged(&#x27;brush&#x27;);
        myself.refreshToolButtons();
        hand.processMouseMove = mouseMoveBak;
        hand.processMouseDown = mouseDownBak;
        hand.processMouseUp = mouseUpBak;
    };
};

// AdvancedColorPickerMorph //////////////////

// A large hsl color picker

PaintColorPickerMorph.prototype = new Morph();
PaintColorPickerMorph.prototype.constructor = PaintColorPickerMorph;
PaintColorPickerMorph.uber = Morph.prototype;

function PaintColorPickerMorph(extent, action) {
    this.init(extent, action);
}

PaintColorPickerMorph.prototype.init = function (extent, action) {
    this.setExtent(extent || new Point(200, 100));
    this.action = action || nop;
    this.drawNew();
};

PaintColorPickerMorph.prototype.drawNew = function () {
    var x = 0,
        y = 0,
        can = newCanvas(this.extent()),
        ctx = can.getContext(&quot;2d&quot;),
        colorselection,
        r;
    for (x = 0; x &lt; this.width(); x += 1) {
        for (y = 0; y &lt; this.height() - 20; y += 1) {
            ctx.fillStyle = &quot;hsl(&quot; +
                (360 * x / this.width()) +
                &quot;,&quot; +
                &quot;100%,&quot; +
                (y * 100 / (this.height() - 20)) +
                &quot;%)&quot;;
            ctx.fillRect(x, y, 1, 1);
        }
    }
    for (x = 0; x &lt; this.width(); x += 1) {
        r = Math.floor(255 * x / this.width());
        ctx.fillStyle = &quot;rgb(&quot; + r + &quot;, &quot; + r + &quot;, &quot; + r + &quot;)&quot;;
        ctx.fillRect(x, this.height() - 20, 1, 10);
    }
    colorselection = [&quot;black&quot;, &quot;white&quot;, &quot;gray&quot;];
    for (x = 0; x &lt; colorselection.length; x += 1) {
        ctx.fillStyle = colorselection[x];
        ctx.fillRect(
            x * this.width() / colorselection.length,
            this.height() - 10,
            this.width() / colorselection.length,
            10
        );
    }
    for (x = this.width() * 2 / 3; x &lt; this.width(); x += 2) {
        for (y = this.height() - 10; y &lt; this.height(); y += 2) {
            if ((x + y) / 2 % 2 === 0) {
                ctx.fillStyle = &quot;#DDD&quot;;
                ctx.fillRect(x, y, 2, 2);
            }
        }
    }
    this.image = can;
};

PaintColorPickerMorph.prototype.mouseDownLeft = function (pos) {
    if ((pos.subtract(this.position()).x &gt; this.width() * 2 / 3) &amp;&amp;
            (pos.subtract(this.position()).y &gt; this.height() - 10)) {
        this.action(&quot;transparent&quot;);
    } else {
        this.action(this.getPixelColor(pos));
    }
};

PaintColorPickerMorph.prototype.mouseMove =
    PaintColorPickerMorph.prototype.mouseDownLeft;

// PaintCanvasMorph ///////////////////////////
/**
* A canvas which reacts to drag events to
    modify its image, based on a &#x27;tool&#x27; property.
*
* @class PaintCanvasMorph
* @constructor
*/
/*
    A canvas which reacts to drag events to
    modify its image, based on a &#x27;tool&#x27; property.
*/

PaintCanvasMorph.prototype = new Morph();
PaintCanvasMorph.prototype.constructor = PaintCanvasMorph;
PaintCanvasMorph.uber = Morph.prototype;

function PaintCanvasMorph(shift) {
    this.init(shift);
}

PaintCanvasMorph.prototype.init = function (shift) {
    this.rotationCenter = new Point(240, 180);
    this.dragRect = null;
    this.previousDragPoint = null;
    this.currentTool = &quot;brush&quot;;
    this.dragRect = new Rectangle();
    // rectangle with origin being the starting drag position and
    // corner being the current drag position
    this.mask = newCanvas(this.extent()); // Temporary canvas
    this.paper = newCanvas(this.extent()); // Actual canvas
    this.erasermask = newCanvas(this.extent()); // eraser memory
    this.background = newCanvas(this.extent()); // checkers
    this.settings = {
        &quot;primarycolor&quot;: new Color(0, 0, 0, 255), // usually fill color
        &quot;secondarycolor&quot;: new Color(0, 0, 0, 255), // (unused)
        &quot;linewidth&quot;: 3 // stroke width
    };
    this.brushBuffer = [];
    this.undoBuffer = [];
    this.isShiftPressed = shift || function () {
        var key = this.world().currentKey;
        return (key === 16);
    };
    this.buildContents();
};

PaintCanvasMorph.prototype.cacheUndo = function () {
    var cachecan = newCanvas(this.extent());
    this.merge(this.paper, cachecan);
    this.undoBuffer.push(cachecan);
};

PaintCanvasMorph.prototype.undo = function () {
    if (this.undoBuffer.length &gt; 0) {
        this.paper = newCanvas(this.extent());
        this.mask.width = this.mask.width + 1 - 1;
        this.merge(this.undoBuffer.pop(), this.paper);
        this.drawNew();
        this.changed();
    }
};

PaintCanvasMorph.prototype.merge = function (a, b) {
    b.getContext(&quot;2d&quot;).drawImage(a, 0, 0);
};

PaintCanvasMorph.prototype.centermerge = function (a, b) {
    b.getContext(&quot;2d&quot;).drawImage(
        a,
        (b.width - a.width) / 2,
        (b.height - a.height) / 2
    );
};

PaintCanvasMorph.prototype.clearCanvas = function () {
    this.buildContents();
    this.drawNew();
    this.changed();
};

PaintCanvasMorph.prototype.toolChanged = function (tool) {
    this.mask = newCanvas(this.extent());
    if (tool === &quot;crosshairs&quot;) {
        this.drawcrosshair();
    }
    this.drawNew();
    this.changed();
};

PaintCanvasMorph.prototype.drawcrosshair = function (context) {
    var ctx = context || this.mask.getContext(&quot;2d&quot;),
        rp = this.rotationCenter;

    ctx.lineWidth = 1;
    ctx.strokeStyle = &#x27;black&#x27;;
    ctx.clearRect(0, 0, this.mask.width, this.mask.height);

    // draw crosshairs:
    ctx.globalAlpha = 0.5;

    // circle around center:
    ctx.fillStyle = &#x27;white&#x27;;
    ctx.beginPath();
    ctx.arc(
        rp.x,
        rp.y,
        20,
        radians(0),
        radians(360),
        false
    );
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(
        rp.x,
        rp.y,
        10,
        radians(0),
        radians(360),
        false
    );
    ctx.stroke();

    // horizontal line:
    ctx.beginPath();
    ctx.moveTo(0, rp.y);
    ctx.lineTo(this.mask.width, rp.y);
    ctx.stroke();

    // vertical line:
    ctx.beginPath();
    ctx.moveTo(rp.x, 0);
    ctx.lineTo(rp.x, this.mask.height);
    ctx.stroke();

    this.drawNew();
    this.changed();
};

PaintCanvasMorph.prototype.floodfill = function (sourcepoint) {
    var width = this.paper.width,
        height = this.paper.height,
        ctx = this.paper.getContext(&quot;2d&quot;),
        img = ctx.getImageData(0, 0, width, height),
        data = img.data,
        stack = [Math.round(sourcepoint.y) * width + sourcepoint.x],
        currentpoint,
        read,
        sourcecolor,
        checkpoint;
    read = function (p) {
        var d = p * 4;
        return [data[d], data[d + 1], data[d + 2], data[d + 3]];
    };
    sourcecolor = read(stack[0]);
    checkpoint = function (p) {
        return p[0] === sourcecolor[0] &amp;&amp;
            p[1] === sourcecolor[1] &amp;&amp;
            p[2] === sourcecolor[2] &amp;&amp;
            p[3] === sourcecolor[3];
    };

    // if already filled, abort
    if (sourcecolor[3] === 0 &amp;&amp;
            this.settings.primarycolor === &quot;transparent&quot;) {
        return;
    }
    if (sourcecolor[0] === this.settings.primarycolor.r &amp;&amp;
            sourcecolor[1] === this.settings.primarycolor.g &amp;&amp;
            sourcecolor[2] === this.settings.primarycolor.b &amp;&amp;
            sourcecolor[3] === this.settings.primarycolor.a) {
        return;
    }
    if (sourcecolor[3] === 0 &amp;&amp; this.settings.primarycolor.a === 0) {
        return;
    }

    while (stack.length &gt; 0) {
        currentpoint = stack.pop();
        if (checkpoint(read(currentpoint))) {
            if (currentpoint % 480 &gt; 1) {
                stack.push(currentpoint + 1);
                stack.push(currentpoint - 1);
            }
            if (currentpoint &gt; 0 &amp;&amp; currentpoint &lt; 360 * 480) {
                stack.push(currentpoint + width);
                stack.push(currentpoint - width);
            }
        }
        if (this.settings.primarycolor === &quot;transparent&quot;) {
            data[currentpoint * 4 + 3] = 0;
        } else {
            data[currentpoint * 4] = this.settings.primarycolor.r;
            data[currentpoint * 4 + 1] = this.settings.primarycolor.g;
            data[currentpoint * 4 + 2] = this.settings.primarycolor.b;
            data[currentpoint * 4 + 3] = this.settings.primarycolor.a;
        }
    }
    ctx.putImageData(img, 0, 0);
    this.drawNew();
    this.changed();
};

PaintCanvasMorph.prototype.mouseDownLeft = function (pos) {
    this.cacheUndo();
    this.dragRect.origin = pos.subtract(this.bounds.origin);
    this.dragRect.corner = pos.subtract(this.bounds.origin);
    this.previousDragPoint = this.dragRect.corner.copy();
    if (this.currentTool === &#x27;crosshairs&#x27;) {
        this.rotationCenter = pos.subtract(this.bounds.origin);
        this.drawcrosshair();
        return;
    }
    if (this.currentTool === &quot;paintbucket&quot;) {
        return this.floodfill(pos.subtract(this.bounds.origin));
    }
    if (this.settings.primarycolor === &quot;transparent&quot; &amp;&amp;
            this.currentTool !== &quot;crosshairs&quot;) {
        this.erasermask = newCanvas(this.extent());
        this.merge(this.paper, this.erasermask);
    }
};

PaintCanvasMorph.prototype.mouseMove = function (pos) {
    if (this.currentTool === &quot;paintbucket&quot;) {
        return;
    }

    var relpos = pos.subtract(this.bounds.origin),
        mctx = this.mask.getContext(&quot;2d&quot;),
        pctx = this.paper.getContext(&quot;2d&quot;),
        x = this.dragRect.origin.x, // original drag X
        y = this.dragRect.origin.y, // original drag y
        p = relpos.x,               // current drag x
        q = relpos.y,               // current drag y
        w = (p - x) / 2,            // half the rect width
        h = (q - y) / 2,            // half the rect height
        i;                          // iterator number
    mctx.save();
    function newW() {
        return Math.max(Math.abs(w), Math.abs(h)) * (w / Math.abs(w));
    }
    function newH() {
        return Math.max(Math.abs(w), Math.abs(h)) * (h / Math.abs(h));
    }
    this.brushBuffer.push([p, q]);
    mctx.lineWidth = this.settings.linewidth;
    mctx.clearRect(0, 0, this.bounds.width(), this.bounds.height()); // mask

    this.dragRect.corner = relpos.subtract(this.dragRect.origin); // reset crn

    if (this.settings.primarycolor === &quot;transparent&quot; &amp;&amp;
            this.currentTool !== &quot;crosshairs&quot;) {
        this.merge(this.erasermask, this.mask);
        pctx.clearRect(0, 0, this.bounds.width(), this.bounds.height());
        mctx.globalCompositeOperation = &quot;destination-out&quot;;
    } else {
        mctx.fillStyle = this.settings.primarycolor.toString();
        mctx.strokeStyle = this.settings.primarycolor.toString();
    }
    switch (this.currentTool) {
    case &quot;rectangle&quot;:
        if (this.isShiftPressed()) {
            mctx.strokeRect(x, y, newW() * 2, newH() * 2);
        } else {
            mctx.strokeRect(x, y, w * 2, h * 2);
        }
        break;
    case &quot;rectangleSolid&quot;:
        if (this.isShiftPressed()) {
            mctx.fillRect(x, y, newW() * 2, newH() * 2);
        } else {
            mctx.fillRect(x, y, w * 2, h * 2);
        }
        break;
    case &quot;brush&quot;:
        mctx.lineCap = &quot;round&quot;;
        mctx.lineJoin = &quot;round&quot;;
        mctx.beginPath();
        mctx.moveTo(this.brushBuffer[0][0], this.brushBuffer[0][1]);
        for (i = 0; i &lt; this.brushBuffer.length; i += 1) {
            mctx.lineTo(this.brushBuffer[i][0], this.brushBuffer[i][1]);
        }
        mctx.stroke();
        break;
    case &quot;line&quot;:
        mctx.beginPath();
        mctx.moveTo(x, y);
        if (this.isShiftPressed()) {
            if (Math.abs(h) &gt; Math.abs(w)) {
                mctx.lineTo(x, q);
            } else {
                mctx.lineTo(p, y);
            }
        } else {
            mctx.lineTo(p, q);
        }
        mctx.stroke();
        break;
    case &quot;circle&quot;:
    case &quot;circleSolid&quot;:
        mctx.beginPath();
        if (this.isShiftPressed()) {
            mctx.arc(
                x,
                y,
                new Point(x, y).distanceTo(new Point(p, q)),
                0,
                Math.PI * 2,
                false
            );
        } else {
            for (i = 0; i &lt; 480; i += 1) {
                mctx.lineTo(
                    i,
                    (2 * h) * Math.sqrt(2 - Math.pow(
                        (i - x) / (2 * w),
                        2
                    )) + y
                );
            }
            for (i = 480; i &gt; 0; i -= 1) {
                mctx.lineTo(
                    i,
                    -1 * (2 * h) * Math.sqrt(2 - Math.pow(
                        (i - x) / (2 * w),
                        2
                    )) + y
                );
            }
        }
        mctx.closePath();
        if (this.currentTool === &quot;circleSolid&quot;) {
            mctx.fill();
        } else {
            if (this.currentTool === &quot;circle&quot;) {
                mctx.stroke();
            }
        }
        break;
    case &quot;crosshairs&quot;:
        this.rotationCenter = relpos.copy();
        this.drawcrosshair(mctx);
        break;
    case &quot;eraser&quot;:
        this.merge(this.paper, this.mask);
        mctx.save();
        mctx.globalCompositeOperation = &quot;destination-out&quot;;
        mctx.beginPath();
        mctx.moveTo(this.brushBuffer[0][0], this.brushBuffer[0][1]);
        for (i = 0; i &lt; this.brushBuffer.length; i += 1) {
            mctx.lineTo(this.brushBuffer[i][0], this.brushBuffer[i][1]);
        }
        mctx.stroke();
        mctx.restore();
        this.paper = newCanvas(this.extent());
        this.merge(this.mask, this.paper);
        break;
    default:
        nop();
    }
    this.previousDragPoint = relpos;
    this.drawNew();
    this.changed();
    mctx.restore();
};

PaintCanvasMorph.prototype.mouseClickLeft = function () {
    if (this.currentTool !== &quot;crosshairs&quot;) {
        this.merge(this.mask, this.paper);
    }
    this.brushBuffer = [];
};

PaintCanvasMorph.prototype.buildContents = function () {
    this.background = newCanvas(this.extent());
    this.paper = newCanvas(this.extent());
    this.mask = newCanvas(this.extent());
    this.erasermask = newCanvas(this.extent());
    var i, j, bkctx = this.background.getContext(&quot;2d&quot;);
    for (i = 0; i &lt; this.background.width; i += 5) {
        for (j = 0; j &lt; this.background.height; j += 5) {
            if ((i + j) / 5 % 2 === 1) {
                bkctx.fillStyle = &quot;rgba(255, 255, 255, 1)&quot;;
            } else {
                bkctx.fillStyle = &quot;rgba(255, 255, 255, 0.3)&quot;;
            }
            bkctx.fillRect(i, j, 5, 5);
        }
    }
};

PaintCanvasMorph.prototype.drawNew = function () {
    var can = newCanvas(this.extent());
    this.merge(this.background, can);
    this.merge(this.paper, can);
    this.merge(this.mask, can);
    this.image = can;
    this.drawFrame();
};

PaintCanvasMorph.prototype.drawFrame = function () {
    var context, borderColor;

    context = this.image.getContext(&#x27;2d&#x27;);
    if (this.parent) {
        this.color = this.parent.color.lighter(this.contrast * 0.75);
        borderColor = this.parent.color;
    } else {
        borderColor = new Color(120, 120, 120);
    }
    context.fillStyle = this.color.toString();

    // cache my border colors
    this.cachedClr = borderColor.toString();
    this.cachedClrBright = borderColor.lighter(this.contrast)
        .toString();
    this.cachedClrDark = borderColor.darker(this.contrast).toString();
    this.drawRectBorder(context);
};

PaintCanvasMorph.prototype.drawRectBorder
    = InputFieldMorph.prototype.drawRectBorder;

PaintCanvasMorph.prototype.edge
    = InputFieldMorph.prototype.edge;

PaintCanvasMorph.prototype.fontSize
    = InputFieldMorph.prototype.fontSize;

PaintCanvasMorph.prototype.typeInPadding
    = InputFieldMorph.prototype.typeInPadding;

PaintCanvasMorph.prototype.contrast
    = InputFieldMorph.prototype.contrast;

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
