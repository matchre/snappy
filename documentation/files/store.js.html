<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>store.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/AlignmentMorph.html">AlignmentMorph</a></li>
            
                <li><a href="../classes/ArgLabelMorph.html">ArgLabelMorph</a></li>
            
                <li><a href="../classes/ArgMorph.html">ArgMorph</a></li>
            
                <li><a href="../classes/ArrowMorph.html">ArrowMorph</a></li>
            
                <li><a href="../classes/BlinkerMorph.html">BlinkerMorph</a></li>
            
                <li><a href="../classes/BlockDialogMorph.html">BlockDialogMorph</a></li>
            
                <li><a href="../classes/BlockEditorMorph.html">BlockEditorMorph</a></li>
            
                <li><a href="../classes/BlockExportDialogMorph.html">BlockExportDialogMorph</a></li>
            
                <li><a href="../classes/BlockHighlightMorph.html">BlockHighlightMorph</a></li>
            
                <li><a href="../classes/BlockImportDialogMorph.html">BlockImportDialogMorph</a></li>
            
                <li><a href="../classes/BlockInputFragmentMorph.html">BlockInputFragmentMorph</a></li>
            
                <li><a href="../classes/BlockLabelFragment.html">BlockLabelFragment</a></li>
            
                <li><a href="../classes/BlockLabelFragmentMorph.html">BlockLabelFragmentMorph</a></li>
            
                <li><a href="../classes/BlockLabelPlaceHolderMorph.html">BlockLabelPlaceHolderMorph</a></li>
            
                <li><a href="../classes/BlockMorph.html">BlockMorph</a></li>
            
                <li><a href="../classes/BooleanSlotMorph.html">BooleanSlotMorph</a></li>
            
                <li><a href="../classes/BouncerMorph.html">BouncerMorph</a></li>
            
                <li><a href="../classes/BoxMorph.html">BoxMorph</a></li>
            
                <li><a href="../classes/CellMorph.html">CellMorph</a></li>
            
                <li><a href="../classes/CircleBoxMorph.html">CircleBoxMorph</a></li>
            
                <li><a href="../classes/Color.html">Color</a></li>
            
                <li><a href="../classes/ColorPaletteMorph.html">ColorPaletteMorph</a></li>
            
                <li><a href="../classes/ColorPickerMorph.html">ColorPickerMorph</a></li>
            
                <li><a href="../classes/ColorSlotMorph.html">ColorSlotMorph</a></li>
            
                <li><a href="../classes/CommandBlockMorph.html">CommandBlockMorph</a></li>
            
                <li><a href="../classes/CommandSlotMorph.html">CommandSlotMorph</a></li>
            
                <li><a href="../classes/CommentMorph.html">CommentMorph</a></li>
            
                <li><a href="../classes/Context.html">Context</a></li>
            
                <li><a href="../classes/Costume.html">Costume</a></li>
            
                <li><a href="../classes/CostumeEditorMorph.html">CostumeEditorMorph</a></li>
            
                <li><a href="../classes/CostumeIconMorph.html">CostumeIconMorph</a></li>
            
                <li><a href="../classes/CSlotMorph.html">CSlotMorph</a></li>
            
                <li><a href="../classes/CursorMorph.html">CursorMorph</a></li>
            
                <li><a href="../classes/CustomBlockDefinition.html">CustomBlockDefinition</a></li>
            
                <li><a href="../classes/CustomCommandBlockMorph.html">CustomCommandBlockMorph</a></li>
            
                <li><a href="../classes/CustomReporterBlockMorph.html">CustomReporterBlockMorph</a></li>
            
                <li><a href="../classes/DialogBoxMorph.html">DialogBoxMorph</a></li>
            
                <li><a href="../classes/FrameMorph.html">FrameMorph</a></li>
            
                <li><a href="../classes/FunctionSlotMorph.html">FunctionSlotMorph</a></li>
            
                <li><a href="../classes/GrayPaletteMorph.html">GrayPaletteMorph</a></li>
            
                <li><a href="../classes/HandleMorph.html">HandleMorph</a></li>
            
                <li><a href="../classes/HandMorph.html">HandMorph</a></li>
            
                <li><a href="../classes/HatBlockMorph.html">HatBlockMorph</a></li>
            
                <li><a href="../classes/IDE_Morph.html">IDE_Morph</a></li>
            
                <li><a href="../classes/InputFieldMorph.html">InputFieldMorph</a></li>
            
                <li><a href="../classes/InputSlotDialogMorph.html">InputSlotDialogMorph</a></li>
            
                <li><a href="../classes/InputSlotMorph.html">InputSlotMorph</a></li>
            
                <li><a href="../classes/InspectorMorph.html">InspectorMorph</a></li>
            
                <li><a href="../classes/JaggedBlockMorph.html">JaggedBlockMorph</a></li>
            
                <li><a href="../classes/JukeboxMorph.html">JukeboxMorph</a></li>
            
                <li><a href="../classes/List.html">List</a></li>
            
                <li><a href="../classes/ListMorph.html">ListMorph</a></li>
            
                <li><a href="../classes/ListWatcherMorph.html">ListWatcherMorph</a></li>
            
                <li><a href="../classes/MenuItemMorph.html">MenuItemMorph</a></li>
            
                <li><a href="../classes/MenuMorph.html">MenuMorph</a></li>
            
                <li><a href="../classes/MouseSensorMorph.html">MouseSensorMorph</a></li>
            
                <li><a href="../classes/MultiArgMorph.html">MultiArgMorph</a></li>
            
                <li><a href="../classes/MyClass.html">MyClass</a></li>
            
                <li><a href="../classes/Node.html">Node</a></li>
            
                <li><a href="../classes/Note.html">Note</a></li>
            
                <li><a href="../classes/PaintCanvasMorph.html">PaintCanvasMorph</a></li>
            
                <li><a href="../classes/PaintEditorMorph.html">PaintEditorMorph</a></li>
            
                <li><a href="../classes/PenMorph.html">PenMorph</a></li>
            
                <li><a href="../classes/Point.html">Point</a></li>
            
                <li><a href="../classes/Process.html">Process</a></li>
            
                <li><a href="../classes/ProjectDialogMorph.html">ProjectDialogMorph</a></li>
            
                <li><a href="../classes/PrototypeHatBlockMorph.html">PrototypeHatBlockMorph</a></li>
            
                <li><a href="../classes/PushButtonMorph.html">PushButtonMorph</a></li>
            
                <li><a href="../classes/ReadStream.html">ReadStream</a></li>
            
                <li><a href="../classes/Rectangle.html">Rectangle</a></li>
            
                <li><a href="../classes/ReporterBlockMorph.html">ReporterBlockMorph</a></li>
            
                <li><a href="../classes/ReporterSlotMorph.html">ReporterSlotMorph</a></li>
            
                <li><a href="../classes/RingCommandSlotMorph.html">RingCommandSlotMorph</a></li>
            
                <li><a href="../classes/RingMorph.html">RingMorph</a></li>
            
                <li><a href="../classes/RingReporterSlotMorph.html">RingReporterSlotMorph</a></li>
            
                <li><a href="../classes/ScriptsMorph.html">ScriptsMorph</a></li>
            
                <li><a href="../classes/ScrollFrameMorph.html">ScrollFrameMorph</a></li>
            
                <li><a href="../classes/ShadowMorph.html">ShadowMorph</a></li>
            
                <li><a href="../classes/SliderButtonMorph.html">SliderButtonMorph</a></li>
            
                <li><a href="../classes/SliderMorph.html">SliderMorph</a></li>
            
                <li><a href="../classes/SnapSerializer.html">SnapSerializer</a></li>
            
                <li><a href="../classes/Sound.html">Sound</a></li>
            
                <li><a href="../classes/SoundIconMorph.html">SoundIconMorph</a></li>
            
                <li><a href="../classes/SpeechBubbleMorph.html">SpeechBubbleMorph</a></li>
            
                <li><a href="../classes/SpriteBubbleMorph.html">SpriteBubbleMorph</a></li>
            
                <li><a href="../classes/SpriteHighlightMorph.html">SpriteHighlightMorph</a></li>
            
                <li><a href="../classes/SpriteMorph.html">SpriteMorph</a></li>
            
                <li><a href="../classes/StageMorph.html">StageMorph</a></li>
            
                <li><a href="../classes/StagePrompterMorph.html">StagePrompterMorph</a></li>
            
                <li><a href="../classes/StringFieldMorph.html">StringFieldMorph</a></li>
            
                <li><a href="../classes/StringMorph.html">StringMorph</a></li>
            
                <li><a href="../classes/SVG_Costume.html">SVG_Costume</a></li>
            
                <li><a href="../classes/SymbolMorph.html">SymbolMorph</a></li>
            
                <li><a href="../classes/SyntaxElementMorph.html">SyntaxElementMorph</a></li>
            
                <li><a href="../classes/TabMorph.html">TabMorph</a></li>
            
                <li><a href="../classes/TemplateSlotMorph.html">TemplateSlotMorph</a></li>
            
                <li><a href="../classes/TextMorph.html">TextMorph</a></li>
            
                <li><a href="../classes/TextSlotMorph.html">TextSlotMorph</a></li>
            
                <li><a href="../classes/ThreadManager.html">ThreadManager</a></li>
            
                <li><a href="../classes/ToggleButtonMorph.html">ToggleButtonMorph</a></li>
            
                <li><a href="../classes/ToggleElementMorph.html">ToggleElementMorph</a></li>
            
                <li><a href="../classes/ToggleMorph.html">ToggleMorph</a></li>
            
                <li><a href="../classes/TriggerMorph.html">TriggerMorph</a></li>
            
                <li><a href="../classes/TurtleIconMorph.html">TurtleIconMorph</a></li>
            
                <li><a href="../classes/UpvarReference.html">UpvarReference</a></li>
            
                <li><a href="../classes/VariableDialogMorph.html">VariableDialogMorph</a></li>
            
                <li><a href="../classes/VariableFrame.html">VariableFrame</a></li>
            
                <li><a href="../classes/WardrobeMorph.html">WardrobeMorph</a></li>
            
                <li><a href="../classes/WatcherMorph.html">WatcherMorph</a></li>
            
                <li><a href="../classes/WorldMorph.html">WorldMorph</a></li>
            
                <li><a href="../classes/XML_Element.html">XML_Element</a></li>
            
                <li><a href="../classes/XML_Serializer.html">XML_Serializer</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: store.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*

    store.js

    saving and loading Snap! projects

    written by Jens Mönig
    jens@moenig.org

    Copyright (C) 2013 by Jens Mönig

    This file is part of Snap!.

    Snap! is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as
    published by the Free Software Foundation, either version 3 of
    the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.


    prerequisites:
    --------------
    needs morphic.js, xml.js, and most of Snap!&#x27;s other modules


    hierarchy
    ---------
    the following tree lists all constructors hierarchically,
    indentation indicating inheritance. Refer to this list to get a
    contextual overview:

        XML_Serializer
            SnapSerializer


    credits
    -------
    Nathan Dinsmore contributed to the design and implemented a first
    working version of a complete XMLSerializer. I have taken much of the
    overall design and many of the functions and methods in this file from
    Nathan&#x27;s fine original prototype.

*/

/*global modules, XML_Element, VariableFrame, StageMorph,
SpriteMorph, WatcherMorph, Point, CustomBlockDefinition, Context,
ReporterBlockMorph, CommandBlockMorph, HatBlockMorph, RingMorph, contains,
detect, CustomCommandBlockMorph, CustomReporterBlockMorph, Color, List,
newCanvas, Costume, Sound, Audio, IDE_Morph, ScriptsMorph, BlockMorph,
ArgMorph, InputSlotMorph, TemplateSlotMorph, CommandSlotMorph,
FunctionSlotMorph, MultiArgMorph, ColorSlotMorph, nop, CommentMorph, isNil,
localize, sizeOf, ArgLabelMorph, SVG_Costume, MorphicPreferences,
SyntaxElementMorph*/

// Global stuff ////////////////////////////////////////////////////////

modules.store = &#x27;2013-December-19&#x27;;


// XML_Serializer ///////////////////////////////////////////////////////
/**
* I am an abstract protype for my heirs.

    I manage object identities and keep track of circular data structures.
    Objects are &quot;touched&quot; and a property named &quot;serializationID&quot; is added
    to each, representing an index integer in the list, starting with 1.
*
* @class XML_Serializer
* @constructor
*/
/*
    I am an abstract protype for my heirs.

    I manage object identities and keep track of circular data structures.
    Objects are &quot;touched&quot; and a property named &quot;serializationID&quot; is added
    to each, representing an index integer in the list, starting with 1.
*/

// XML_Serializer instance creation:

function XML_Serializer() {
    this.contents = [];
    this.media = [];
    this.isCollectingMedia = false;
}

// XML_Serializer preferences settings:

XML_Serializer.prototype.idProperty = &#x27;serializationID&#x27;;
XML_Serializer.prototype.mediaIdProperty = &#x27;serializationMediaID&#x27;;
XML_Serializer.prototype.mediaDetectionProperty = &#x27;isMedia&#x27;;
XML_Serializer.prototype.version = 1; // increment on structural change

// XML_Serializer accessing:

XML_Serializer.prototype.serialize = function (object) {
    // public: answer an XML string representing the given object
    var xml;
    this.flush(); // in case an error occurred in an earlier attempt
    this.flushMedia();
    xml = this.store(object);
    this.flush();
    return xml;
};

XML_Serializer.prototype.store = function (object, mediaID) {
    // private - mediaID is optional
    if (isNil(object) || !object.toXML) {
        // unsupported type, to be checked before calling store()
        // when debugging, be sure to throw an error at this point
        return &#x27;&#x27;;
    }
    if (this.isCollectingMedia &amp;&amp; object[this.mediaDetectionProperty]) {
        this.addMedia(object, mediaID);
        return this.format(
            &#x27;&lt;ref mediaID=&quot;@&quot;&gt;&lt;/ref&gt;&#x27;,
            object[this.mediaIdProperty]
        );
    }
    if (object[this.idProperty]) {
        return this.format(&#x27;&lt;ref id=&quot;@&quot;&gt;&lt;/ref&gt;&#x27;, object[this.idProperty]);
    }
    this.add(object);
    return object.toXML(this, mediaID).replace(
        &#x27;~&#x27;,
        this.format(&#x27;id=&quot;@&quot;&#x27;, object[this.idProperty])
    );
};

XML_Serializer.prototype.mediaXML = function () {
    // answer a project&#x27;s collected media module as XML
    var xml = &#x27;&lt;media&gt;&#x27;,
        myself = this;
    this.media.forEach(function (object) {
        var str = object.toXML(myself).replace(
            &#x27;~&#x27;,
            myself.format(&#x27;mediaID=&quot;@&quot;&#x27;, object[myself.mediaIdProperty])
        );
        xml = xml + str;
    });
    return xml + &#x27;&lt;/media&gt;&#x27;;
};

XML_Serializer.prototype.add = function (object) {
    // private - mark the object with a serializationID property and add it
    if (object[this.idProperty]) { // already present
        return -1;
    }
    this.contents.push(object);
    object[this.idProperty] = this.contents.length;
    return this.contents.length;
};

XML_Serializer.prototype.addMedia = function (object, mediaID) {
    // private - mark the object with a serializationMediaID property
    // and add it to media
    // if a mediaID is given, take it, otherwise generate one
    if (object[this.mediaIdProperty]) { // already present
        return -1;
    }
    this.media.push(object);
    if (mediaID) {
        object[this.mediaIdProperty] = mediaID + &#x27;_&#x27; + object.name;
    } else {
        object[this.mediaIdProperty] = this.media.length;
    }
    return this.media.length;
};

XML_Serializer.prototype.at = function (integer) {
    // private
    return this.contents[integer - 1];
};

XML_Serializer.prototype.flush = function () {
    // private - free all objects and empty my contents
    var myself = this;
    this.contents.forEach(function (obj) {
        delete obj[myself.idProperty];
    });
    this.contents = [];
};

XML_Serializer.prototype.flushMedia = function () {
    // private - free all media objects and empty my media
    var myself = this;
    if (this.media instanceof Array) {
        this.media.forEach(function (obj) {
            delete obj[myself.mediaIdProperty];
        });
    }
    this.media = [];
};

// XML_Serializer formatting:

XML_Serializer.prototype.escape = XML_Element.prototype.escape;
XML_Serializer.prototype.unescape = XML_Element.prototype.unescape;


XML_Serializer.prototype.format = function (string) {
    // private
    var myself = this,
        i = -1,
        values = arguments,
        value;

    return string.replace(/[@$%]([\d]+)?/g, function (spec, index) {
        index = parseInt(index, 10);

        if (isNaN(index)) {
            i += 1;
            value = values[i + 1];
        } else {
            value = values[index + 1];
        }
        // original line of code - now frowned upon by JSLint:
        // value = values[(isNaN(index) ? (i += 1) : index) + 1];

        return spec === &#x27;@&#x27; ?
                myself.escape(value)
                    : spec === &#x27;$&#x27; ?
                        myself.escape(value, true)
                            : value;
    });
};

// XML_Serializer loading:

XML_Serializer.prototype.load = function (xmlString) {
    // public - answer a new object which is represented by the given
    // XML string.
    nop(xmlString);
    throw new Error(
        &#x27;loading should be implemented in heir of XML_Serializer&#x27;
    );
};

XML_Serializer.prototype.parse = function (xmlString) {
    // private - answer an XML_Element representing the given XML String
    var element = new XML_Element();
    element.parseString(xmlString);
    return element;
};

// SnapSerializer ////////////////////////////////////////////////////////////
/**
* SnapSerializer inherits from XML_Serializer:
*
* @class SnapSerializer
* @constructor
*/
var SnapSerializer;

// SnapSerializer inherits from XML_Serializer:

SnapSerializer.prototype = new XML_Serializer();
SnapSerializer.prototype.constructor = SnapSerializer;
SnapSerializer.uber = XML_Serializer.prototype;

// SnapSerializer constants:

SnapSerializer.prototype.app = &#x27;Snap! 4.0, http://snap.berkeley.edu&#x27;;

SnapSerializer.prototype.thumbnailSize = new Point(160, 120);

SnapSerializer.prototype.watcherLabels = {
    xPosition: &#x27;x position&#x27;,
    yPosition: &#x27;y position&#x27;,
    direction: &#x27;direction&#x27;,
    getScale: &#x27;size&#x27;,
    getLastAnswer: &#x27;answer&#x27;,
    getTimer: &#x27;timer&#x27;,
    getCostumeIdx: &#x27;costume #&#x27;,
    reportMouseX: &#x27;mouse x&#x27;,
    reportMouseY: &#x27;mouse y&#x27;
};

// SnapSerializer instance creation:

function SnapSerializer() {
    this.init();
}

// SnapSerializer initialization:

SnapSerializer.prototype.init = function () {
    this.project = {};
    this.objects = {};
    this.mediaDict = {};
};

// SnapSerializer saving:

XML_Serializer.prototype.mediaXML = function (name) {
    // under construction....
    var xml = &#x27;&lt;media name=&quot;&#x27; +
            (name || &#x27;untitled&#x27;) +
            &#x27;&quot; app=&quot;&#x27; + this.app +
            &#x27;&quot; version=&quot;&#x27; +
            this.version +
            &#x27;&quot;&gt;&#x27;,
        myself = this;
    this.media.forEach(function (object) {
        var str = object.toXML(myself).replace(
            &#x27;~&#x27;,
            myself.format(&#x27;mediaID=&quot;@&quot;&#x27;, object[myself.mediaIdProperty])
        );
        xml = xml + str;
    });
    return xml + &#x27;&lt;/media&gt;&#x27;;
};


// SnapSerializer loading:

SnapSerializer.prototype.load = function (xmlString) {
    // public - answer a new Project represented by the given XML String
    return this.loadProjectModel(this.parse(xmlString));
};

SnapSerializer.prototype.loadProjectModel = function (xmlNode) {
    // public - answer a new Project represented by the given XML top node
    var myself = this,
        project = {sprites: {}},
        model,
        nameID;

    this.project = project;

    model = {project: xmlNode };
    if (+xmlNode.attributes.version &gt; this.version) {
        throw &#x27;Project uses newer version of Serializer&#x27;;
    }

    /* Project Info */

    this.objects = {};
    project.name = model.project.attributes.name;
    if (!project.name) {
        nameID = 1;
        while (
            Object.prototype.hasOwnProperty.call(
                localStorage,
                &#x27;-snap-project-Untitled &#x27; + nameID
            )
        ) {
            nameID += 1;
        }
        project.name = &#x27;Untitled &#x27; + nameID;
    }
    model.notes = model.project.childNamed(&#x27;notes&#x27;);
    if (model.notes) {
        project.notes = model.notes.contents;
    }
    model.globalVariables = model.project.childNamed(&#x27;variables&#x27;);
    project.globalVariables = new VariableFrame();

    /* Stage */

    model.stage = model.project.require(&#x27;stage&#x27;);
    StageMorph.prototype.frameRate = 0;
    project.stage = new StageMorph(project.globalVariables);
    if (Object.prototype.hasOwnProperty.call(
            model.stage.attributes,
            &#x27;id&#x27;
        )) {
        this.objects[model.stage.attributes.id] = project.stage;
    }
    if (model.stage.attributes.name) {
        project.stage.name = model.stage.attributes.name;
    }
    if (model.stage.attributes.scheduled === &#x27;true&#x27;) {
        project.stage.fps = 30;
        StageMorph.prototype.frameRate = 30;
    }
    model.pentrails = model.stage.childNamed(&#x27;pentrails&#x27;);
    if (model.pentrails) {
        project.pentrails = new Image();
        project.pentrails.onload = function () {
            var context = project.stage.trailsCanvas.getContext(&#x27;2d&#x27;);
            context.drawImage(project.pentrails, 0, 0);
            project.stage.changed();
        };
        project.pentrails.src = model.pentrails.contents;
    }
    project.stage.setTempo(model.stage.attributes.tempo);
    project.stage.setExtent(StageMorph.prototype.dimensions);
    project.stage.isThreadSafe =
        model.stage.attributes.threadsafe === &#x27;true&#x27;;
    StageMorph.prototype.enableCodeMapping =
        model.stage.attributes.codify === &#x27;true&#x27;;

    model.hiddenPrimitives = model.project.childNamed(&#x27;hidden&#x27;);
    if (model.hiddenPrimitives) {
        model.hiddenPrimitives.contents.split(&#x27; &#x27;).forEach(
            function (sel) {
                if (sel) {
                    StageMorph.prototype.hiddenPrimitives[sel] = true;
                }
            }
        );
    }

    model.codeHeaders = model.project.childNamed(&#x27;headers&#x27;);
    if (model.codeHeaders) {
        model.codeHeaders.children.forEach(function (xml) {
            StageMorph.prototype.codeHeaders[xml.tag] = xml.contents;
        });
    }

    model.codeMappings = model.project.childNamed(&#x27;code&#x27;);
    if (model.codeMappings) {
        model.codeMappings.children.forEach(function (xml) {
            StageMorph.prototype.codeMappings[xml.tag] = xml.contents;
        });
    }

    model.globalBlocks = model.project.childNamed(&#x27;blocks&#x27;);
    if (model.globalBlocks) {
        this.loadCustomBlocks(project.stage, model.globalBlocks, true);
        this.populateCustomBlocks(
            project.stage,
            model.globalBlocks,
            true
        );
    }
    this.loadObject(project.stage, model.stage);

    /* Sprites */

    model.sprites = model.stage.require(&#x27;sprites&#x27;);
    project.sprites[project.stage.name] = project.stage;

    model.sprites.childrenNamed(&#x27;sprite&#x27;).forEach(function (model) {
        myself.loadValue(model);
    });

    // restore nesting associations
    myself.project.stage.children.forEach(function (sprite) {
        var anchor;
        if (sprite.nestingInfo) { // only sprites may have nesting info
            anchor = myself.project.sprites[sprite.nestingInfo.anchor];
            if (anchor) {
                anchor.attachPart(sprite);
            }
            sprite.rotatesWithAnchor = (sprite.nestingInfo.synch === &#x27;true&#x27;);
        }
    });
    myself.project.stage.children.forEach(function (sprite) {
        if (sprite.nestingInfo) { // only sprites may have nesting info
            sprite.nestingScale = +(sprite.nestingInfo.scale || sprite.scale);
            delete sprite.nestingInfo;
        }
    });

    this.objects = {};

    /* Global Variables */

    if (model.globalVariables) {
        this.loadVariables(
            project.globalVariables,
            model.globalVariables
        );
    }

    /* Watchers */

    model.sprites.childrenNamed(&#x27;watcher&#x27;).forEach(function (model) {
        var watcher, color, target, hidden, extX, extY;

        color = myself.loadColor(model.attributes.color);
        target = Object.prototype.hasOwnProperty.call(
            model.attributes,
            &#x27;scope&#x27;
        ) ? project.sprites[model.attributes.scope] : null;

        // determine whether the watcher is hidden, slightly
        // complicated to retain backward compatibility
        // with former tag format: hidden=&quot;hidden&quot;
        // now it&#x27;s: hidden=&quot;true&quot;
        hidden = Object.prototype.hasOwnProperty.call(
            model.attributes,
            &#x27;hidden&#x27;
        ) &amp;&amp; (model.attributes.hidden !== &#x27;false&#x27;);

        if (Object.prototype.hasOwnProperty.call(
                model.attributes,
                &#x27;var&#x27;
            )) {
            watcher = new WatcherMorph(
                model.attributes[&#x27;var&#x27;],
                color,
                isNil(target) ? project.globalVariables
                    : target.variables,
                model.attributes[&#x27;var&#x27;],
                hidden
            );
        } else {
            watcher = new WatcherMorph(
                localize(myself.watcherLabels[model.attributes.s]),
                color,
                target,
                model.attributes.s,
                hidden
            );
        }
        watcher.setStyle(model.attributes.style || &#x27;normal&#x27;);
        if (watcher.style === &#x27;slider&#x27;) {
            watcher.setSliderMin(model.attributes.min || &#x27;1&#x27;);
            watcher.setSliderMax(model.attributes.max || &#x27;100&#x27;);
        }
        watcher.setPosition(
            project.stage.topLeft().add(new Point(
                +model.attributes.x || 0,
                +model.attributes.y || 0
            ))
        );
        project.stage.add(watcher);
        watcher.update();

        // set watcher&#x27;s contentsMorph&#x27;s extent if it is showing a list and
        // its monitor dimensions are given
        if (watcher.currentValue instanceof List) {
            extX = model.attributes.extX;
            if (extX) {
                watcher.cellMorph.contentsMorph.setWidth(+extX);
            }
            extY = model.attributes.extY;
            if (extY) {
                watcher.cellMorph.contentsMorph.setHeight(+extY);
            }
            // adjust my contentsMorph&#x27;s handle position
            watcher.cellMorph.contentsMorph.handle.drawNew();
        }
    });
    this.objects = {};
    return project;
};

SnapSerializer.prototype.loadBlocks = function (xmlString, targetStage) {
    // public - answer a new Array of custom block definitions
    // represented by the given XML String
    var stage = new StageMorph(),
        model;

    this.project = {
        stage: stage,
        sprites: {},
        targetStage: targetStage // for secondary custom block def look-up
    };
    model = this.parse(xmlString);
    if (+model.attributes.version &gt; this.version) {
        throw &#x27;Module uses newer version of Serializer&#x27;;
    }
    this.loadCustomBlocks(stage, model, true);
    this.populateCustomBlocks(
        stage,
        model,
        true
    );
    this.objects = {};
    stage.globalBlocks.forEach(function (def) {
        def.receiver = null;
    });
    this.objects = {};
    this.project = {};
    this.mediaDict = {};
    return stage.globalBlocks;
};

SnapSerializer.prototype.loadSprites = function (xmlString, ide) {
    // public - import a set of sprites represented by xmlString
    // into the current project of the ide
    var model, project, myself = this;

    project = this.project = {
        globalVariables: ide.globalVariables,
        stage: ide.stage,
        sprites: {}
    };
    project.sprites[project.stage.name] = project.stage;

    model = this.parse(xmlString);
    if (+model.attributes.version &gt; this.version) {
        throw &#x27;Module uses newer version of Serializer&#x27;;
    }
    model.childrenNamed(&#x27;sprite&#x27;).forEach(function (model) {
        var sprite  = new SpriteMorph(project.globalVariables);

        if (model.attributes.id) {
            myself.objects[model.attributes.id] = sprite;
        }
        if (model.attributes.name) {
            sprite.name = model.attributes.name;
            project.sprites[model.attributes.name] = sprite;
        }
        if (model.attributes.color) {
            sprite.color = myself.loadColor(model.attributes.color);
        }
        if (model.attributes.pen) {
            sprite.penPoint = model.attributes.pen;
        }
        project.stage.add(sprite);
        ide.sprites.add(sprite);
        sprite.scale = parseFloat(model.attributes.scale || &#x27;1&#x27;);
        sprite.rotationStyle = parseFloat(
            model.attributes.rotation || &#x27;1&#x27;
        );
        sprite.isDraggable = model.attributes.draggable !== &#x27;false&#x27;;
        sprite.isVisible = model.attributes.hidden !== &#x27;true&#x27;;
        sprite.heading = parseFloat(model.attributes.heading) || 0;
        sprite.drawNew();
        sprite.gotoXY(+model.attributes.x || 0, +model.attributes.y || 0);
        myself.loadObject(sprite, model);
    });
    this.objects = {};
    this.project = {};
    this.mediaDict = {};

//    ide.stage.drawNew();
    ide.createCorral();
    ide.fixLayout();
};

SnapSerializer.prototype.loadMedia = function (xmlString) {
    // public - load the media represented by xmlString into memory
    // to be referenced by a media-less project later
    return this.loadMediaModel(this.parse(xmlString));
};

SnapSerializer.prototype.loadMediaModel = function (xmlNode) {
    // public - load the media represented by xmlNode into memory
    // to be referenced by a media-less project later
    var myself = this,
        model = xmlNode;
    this.mediaDict = {};
    if (+model.attributes.version &gt; this.version) {
        throw &#x27;Module uses newer version of Serializer&#x27;;
    }
    model.children.forEach(function (model) {
        myself.loadValue(model);
    });
    return this.mediaDict;
};

SnapSerializer.prototype.loadObject = function (object, model) {
    // private
    var blocks = model.require(&#x27;blocks&#x27;);
    this.loadNestingInfo(object, model);
    this.loadCostumes(object, model);
    this.loadSounds(object, model);
    this.loadCustomBlocks(object, blocks);
    this.populateCustomBlocks(object, blocks);
    this.loadVariables(object.variables, model.require(&#x27;variables&#x27;));
    this.loadScripts(object.scripts, model.require(&#x27;scripts&#x27;));
};

SnapSerializer.prototype.loadNestingInfo = function (object, model) {
    // private
    var info = model.childNamed(&#x27;nest&#x27;);
    if (info) {
        object.nestingInfo = info.attributes;
    }
};

SnapSerializer.prototype.loadCostumes = function (object, model) {
    // private
    var costumes = model.childNamed(&#x27;costumes&#x27;),
        costume;
    if (costumes) {
        object.costumes = this.loadValue(costumes.require(&#x27;list&#x27;));
    }
    if (Object.prototype.hasOwnProperty.call(
            model.attributes,
            &#x27;costume&#x27;
        )) {
        costume = object.costumes.asArray()[model.attributes.costume - 1];
        if (costume) {
            if (costume.loaded) {
                object.wearCostume(costume);
            } else {
                costume.loaded = function () {
                    object.wearCostume(costume);
                    this.loaded = true;
                };
            }
        }
    }
};

SnapSerializer.prototype.loadSounds = function (object, model) {
    // private
    var sounds = model.childNamed(&#x27;sounds&#x27;);
    if (sounds) {
        object.sounds = this.loadValue(sounds.require(&#x27;list&#x27;));
    }
};

SnapSerializer.prototype.loadVariables = function (varFrame, element) {
    // private
    var myself = this;

    element.children.forEach(function (child) {
        var value;
        if (child.tag !== &#x27;variable&#x27;) {
            return;
        }
        value = child.children[0];
        varFrame.vars[child.attributes.name] = value ?
                myself.loadValue(value) : 0;
    });
};

SnapSerializer.prototype.loadCustomBlocks = function (
    object,
    element,
    isGlobal
) {
    // private
    var myself = this;
    element.children.forEach(function (child) {
        var definition, names, inputs, header, code, comment, i;
        if (child.tag !== &#x27;block-definition&#x27;) {
            return;
        }
        definition = new CustomBlockDefinition(
            child.attributes.s || &#x27;&#x27;,
            object
        );
        definition.category = child.attributes.category || &#x27;other&#x27;;
        definition.type = child.attributes.type || &#x27;command&#x27;;
        definition.isGlobal = (isGlobal === true);
        if (definition.isGlobal) {
            object.globalBlocks.push(definition);
        } else {
            object.customBlocks.push(definition);
        }

        names = definition.parseSpec(definition.spec).filter(
            function (str) {
                return str.charAt(0) === &#x27;%&#x27;;
            }
        ).map(function (str) {
            return str.substr(1);
        });

        definition.names = names;
        inputs = child.childNamed(&#x27;inputs&#x27;);
        if (inputs) {
            i = -1;
            inputs.children.forEach(function (child) {
                var options = child.childNamed(&#x27;options&#x27;);
                if (child.tag !== &#x27;input&#x27;) {
                    return;
                }
                i += 1;
                definition.declarations[names[i]] = [
                    child.attributes.type,
                    child.contents,
                    options ? options.contents : undefined,
                    child.attributes.readonly === &#x27;true&#x27;
                ];
            });
        }

        header = child.childNamed(&#x27;header&#x27;);
        if (header) {
            definition.codeHeader = header.contents;
        }

        code = child.childNamed(&#x27;code&#x27;);
        if (code) {
            definition.codeMapping = code.contents;
        }

        comment = child.childNamed(&#x27;comment&#x27;);
        if (comment) {
            definition.comment = myself.loadComment(comment);
        }
    });
};

SnapSerializer.prototype.populateCustomBlocks = function (
    object,
    element,
    isGlobal
) {
    // private
    var myself = this;
    element.children.forEach(function (child, index) {
        var definition, script, scripts;
        if (child.tag !== &#x27;block-definition&#x27;) {
            return;
        }
        definition = isGlobal ? object.globalBlocks[index]
                : object.customBlocks[index];
        script = child.childNamed(&#x27;script&#x27;);
        if (script) {
            definition.body = new Context(
                null,
                script ? myself.loadScript(script) : null,
                null,
                object
            );
            definition.body.inputs = definition.names.slice(0);
        }
        scripts = child.childNamed(&#x27;scripts&#x27;);
        if (scripts) {
            definition.scripts = myself.loadScriptsArray(scripts);
        }

        delete definition.names;
    });
};

SnapSerializer.prototype.loadScripts = function (scripts, model) {
    // private
    var myself = this,
        scale = SyntaxElementMorph.prototype.scale;
    scripts.texture = &#x27;scriptsPaneTexture.gif&#x27;;
    model.children.forEach(function (child) {
        var element;
        if (child.tag === &#x27;script&#x27;) {
            element = myself.loadScript(child);
            if (!element) {
                return;
            }
            element.setPosition(new Point(
                (+child.attributes.x || 0) * scale,
                (+child.attributes.y || 0) * scale
            ).add(scripts.topLeft()));
            scripts.add(element);
            element.fixBlockColor(null, true); // force zebra coloring
            element.allComments().forEach(function (comment) {
                comment.align(element);
            });
        } else if (child.tag === &#x27;comment&#x27;) {
            element = myself.loadComment(child);
            if (!element) {
                return;
            }
            element.setPosition(new Point(
                (+child.attributes.x || 0) * scale,
                (+child.attributes.y || 0) * scale
            ).add(scripts.topLeft()));
            scripts.add(element);
        }
    });
};

SnapSerializer.prototype.loadScriptsArray = function (model) {
    // private - answer an array containting the model&#x27;s scripts
    var myself = this,
        scale = SyntaxElementMorph.prototype.scale,
        scripts = [];
    model.children.forEach(function (child) {
        var element;
        if (child.tag === &#x27;script&#x27;) {
            element = myself.loadScript(child);
            if (!element) {
                return;
            }
            element.setPosition(new Point(
                (+child.attributes.x || 0) * scale,
                (+child.attributes.y || 0) * scale
            ));
            scripts.push(element);
            element.fixBlockColor(null, true); // force zebra coloring
        } else if (child.tag === &#x27;comment&#x27;) {
            element = myself.loadComment(child);
            if (!element) {
                return;
            }
            element.setPosition(new Point(
                (+child.attributes.x || 0) * scale,
                (+child.attributes.y || 0) * scale
            ));
            scripts.push(element);
        }
    });
    return scripts;
};

SnapSerializer.prototype.loadScript = function (model) {
    // private
    var topBlock, block, nextBlock,
        myself = this;
    model.children.forEach(function (child) {
        nextBlock = myself.loadBlock(child);
        if (!nextBlock) {
            return;
        }
        if (block) {
            block.nextBlock(nextBlock);
        } else {
            topBlock = nextBlock;
        }
        block = nextBlock;
    });
    return topBlock;
};

SnapSerializer.prototype.loadComment = function (model) {
    // private
    var comment = new CommentMorph(model.contents),
        scale = SyntaxElementMorph.prototype.scale;
    comment.isCollapsed = (model.attributes.collapsed === &#x27;true&#x27;);
    comment.setTextWidth(+model.attributes.w * scale);
    return comment;
};

SnapSerializer.prototype.loadBlock = function (model, isReporter) {
    // private
    var block, info, inputs, isGlobal, rm, receiver;
    if (model.tag === &#x27;block&#x27;) {
        if (Object.prototype.hasOwnProperty.call(
                model.attributes,
                &#x27;var&#x27;
            )) {
            return SpriteMorph.prototype.variableBlock(
                model.attributes[&#x27;var&#x27;]
            );
        }
        block = SpriteMorph.prototype.blockForSelector(model.attributes.s);
    } else if (model.tag === &#x27;custom-block&#x27;) {
        isGlobal = model.attributes.scope ? false : true;
        receiver = isGlobal ? this.project.stage
            : this.project.sprites[model.attributes.scope];
        rm = model.childNamed(&#x27;receiver&#x27;);
        if (rm &amp;&amp; rm.children[0]) {
            receiver = this.loadValue(
                model.childNamed(&#x27;receiver&#x27;).children[0]
            );
        }
        if (!receiver) {
            return this.obsoleteBlock(isReporter);
        }
        if (isGlobal) {
            info = detect(receiver.globalBlocks, function (block) {
                return block.blockSpec() === model.attributes.s;
            });
            if (!info &amp;&amp; this.project.targetStage) { // importing block files
                info = detect(
                    this.project.targetStage.globalBlocks,
                    function (block) {
                        return block.blockSpec() === model.attributes.s;
                    }
                );
            }
        } else {
            info = detect(receiver.customBlocks, function (block) {
                return block.blockSpec() === model.attributes.s;
            });
        }
        if (!info) {
            return this.obsoleteBlock(isReporter);
        }
        block = info.type === &#x27;command&#x27; ? new CustomCommandBlockMorph(
            info,
            false
        ) : new CustomReporterBlockMorph(
            info,
            info.type === &#x27;predicate&#x27;,
            false
        );
    }
    if (block === null) {
        block = this.obsoleteBlock(isReporter);
    }
    block.isDraggable = true;
    inputs = block.inputs();
    model.children.forEach(function (child, i) {
        if (child.tag === &#x27;comment&#x27;) {
            block.comment = this.loadComment(child);
            block.comment.block = block;
        } else if (child.tag === &#x27;receiver&#x27;) {
            nop(); // ignore
        } else {
            this.loadInput(child, inputs[i], block);
        }
    }, this);
    return block;
};

SnapSerializer.prototype.obsoleteBlock = function (isReporter) {
    // private
    var block = isReporter ? new ReporterBlockMorph()
            : new CommandBlockMorph();
    block.selector = &#x27;nop&#x27;;
    block.color = new Color(200, 0, 20);
    block.setSpec(&#x27;Obsolete!&#x27;);
    block.isDraggable = true;
    return block;
};

SnapSerializer.prototype.loadInput = function (model, input, block) {
    // private
    var inp, val, myself = this;
    if (model.tag === &#x27;script&#x27;) {
        inp = this.loadScript(model);
        if (inp) {
            input.add(inp);
            input.fixLayout();
        }
    } else if (model.tag === &#x27;autolambda&#x27; &amp;&amp; model.children[0]) {
        inp = this.loadBlock(model.children[0], true);
        if (inp) {
            input.silentReplaceInput(input.children[0], inp);
            input.fixLayout();
        }
    } else if (model.tag === &#x27;list&#x27;) {
        while (input.inputs().length &gt; 0) {
            input.removeInput();
        }
        model.children.forEach(function (item) {
            input.addInput();
            myself.loadInput(
                item,
                input.children[input.children.length - 2],
                input
            );
        });
        input.fixLayout();
    } else if (model.tag === &#x27;block&#x27; || model.tag === &#x27;custom-block&#x27;) {
        block.silentReplaceInput(input, this.loadBlock(model, true));
    } else if (model.tag === &#x27;color&#x27;) {
        input.setColor(this.loadColor(model.contents));
    } else {
        val = this.loadValue(model);
        if (val) {
            input.setContents(this.loadValue(model));
        }
    }
};

SnapSerializer.prototype.loadValue = function (model) {
    // private
    var v, items, el, center, image, name, audio, option,
        myself = this;

    function record() {
        if (Object.prototype.hasOwnProperty.call(
                model.attributes,
                &#x27;id&#x27;
            )) {
            myself.objects[model.attributes.id] = v;
        }
        if (Object.prototype.hasOwnProperty.call(
                model.attributes,
                &#x27;mediaID&#x27;
            )) {
            myself.mediaDict[model.attributes.mediaID] = v;
        }
    }
    switch (model.tag) {
    case &#x27;ref&#x27;:
        if (Object.prototype.hasOwnProperty.call(model.attributes, &#x27;id&#x27;)) {
            return this.objects[model.attributes.id];
        }
        if (Object.prototype.hasOwnProperty.call(
                model.attributes,
                &#x27;mediaID&#x27;
            )) {
            return this.mediaDict[model.attributes.mediaID];
        }
        throw new Error(&#x27;expecting a reference id&#x27;);
    case &#x27;l&#x27;:
        option = model.childNamed(&#x27;option&#x27;);
        return option ? [option.contents] : model.contents;
    case &#x27;bool&#x27;:
        return model.contents === &#x27;true&#x27;;
    case &#x27;list&#x27;:
        if (model.attributes.hasOwnProperty(&#x27;linked&#x27;)) {
            items = model.childrenNamed(&#x27;item&#x27;);
            if (items.length === 0) {
                v = new List();
                record();
                return v;
            }
            items.forEach(function (item) {
                var value = item.children[0];
                if (v === undefined) {
                    v = new List();
                    record();
                } else {
                    v = v.rest = new List();
                }
                v.isLinked = true;
                if (!value) {
                    v.first = 0;
                } else {
                    v.first = myself.loadValue(value);
                }
            });
            return v;
        }
        v = new List();
        record();
        v.contents = model.childrenNamed(&#x27;item&#x27;).map(function (item) {
            var value = item.children[0];
            if (!value) {
                return 0;
            }
            return myself.loadValue(value);
        });
        return v;
    case &#x27;sprite&#x27;:
        v  = new SpriteMorph(myself.project.globalVariables);
        if (model.attributes.id) {
            myself.objects[model.attributes.id] = v;
        }
        if (model.attributes.name) {
            v.name = model.attributes.name;
            myself.project.sprites[model.attributes.name] = v;
        }
        if (model.attributes.idx) {
            v.idx = +model.attributes.idx;
        }
        if (model.attributes.color) {
            v.color = myself.loadColor(model.attributes.color);
        }
        if (model.attributes.pen) {
            v.penPoint = model.attributes.pen;
        }
        myself.project.stage.add(v);
        v.scale = parseFloat(model.attributes.scale || &#x27;1&#x27;);
        v.rotationStyle = parseFloat(
            model.attributes.rotation || &#x27;1&#x27;
        );
        v.isDraggable = model.attributes.draggable !== &#x27;false&#x27;;
        v.isVisible = model.attributes.hidden !== &#x27;true&#x27;;
        v.heading = parseFloat(model.attributes.heading) || 0;
        v.drawNew();
        v.gotoXY(+model.attributes.x || 0, +model.attributes.y || 0);
        myself.loadObject(v, model);
        return v;
    case &#x27;context&#x27;:
        v = new Context(null);
        record();
        el = model.childNamed(&#x27;script&#x27;);
        if (el) {
            v.expression = this.loadScript(el);
        } else {
            el = model.childNamed(&#x27;block&#x27;) ||
                model.childNamed(&#x27;custom-block&#x27;);
            if (el) {
                v.expression = this.loadBlock(el);
            } else {
                el = model.childNamed(&#x27;l&#x27;);
                if (el) {
                    v.expression = new InputSlotMorph(el.contents);
                }
            }
        }
        el = model.childNamed(&#x27;receiver&#x27;);
        if (el) {
            el = el.childNamed(&#x27;ref&#x27;) || el.childNamed(&#x27;sprite&#x27;);
            if (el) {
                v.receiver = this.loadValue(el);
            }
        }
        el = model.childNamed(&#x27;inputs&#x27;);
        if (el) {
            el.children.forEach(function (item) {
                if (item.tag === &#x27;input&#x27;) {
                    v.inputs.push(item.contents);
                }
            });
        }
        el = model.childNamed(&#x27;variables&#x27;);
        if (el) {
            this.loadVariables(v.variables, el);
        }
        el = model.childNamed(&#x27;context&#x27;);
        if (el) {
            v.outerContext = this.loadValue(el);
        }
        return v;
    case &#x27;costume&#x27;:
        center = new Point();
        if (Object.prototype.hasOwnProperty.call(
                model.attributes,
                &#x27;center-x&#x27;
            )) {
            center.x = parseFloat(model.attributes[&#x27;center-x&#x27;]);
        }
        if (Object.prototype.hasOwnProperty.call(
                model.attributes,
                &#x27;center-y&#x27;
            )) {
            center.y = parseFloat(model.attributes[&#x27;center-y&#x27;]);
        }
        if (Object.prototype.hasOwnProperty.call(
                model.attributes,
                &#x27;name&#x27;
            )) {
            name = model.attributes.name;
        }
        if (Object.prototype.hasOwnProperty.call(
                model.attributes,
                &#x27;image&#x27;
            )) {
            image = new Image();
            if (model.attributes.image.indexOf(&#x27;data:image/svg+xml&#x27;) === 0
                    &amp;&amp; !MorphicPreferences.rasterizeSVGs) {
                v = new SVG_Costume(null, name, center);
                image.onload = function () {
                    v.contents = image;
                    v.version = +new Date();
                    if (typeof v.loaded === &#x27;function&#x27;) {
                        v.loaded();
                    } else {
                        v.loaded = true;
                    }
                };
            } else {
                v = new Costume(null, name, center);
                image.onload = function () {
                    var canvas = newCanvas(
                            new Point(image.width, image.height)
                        ),
                        context = canvas.getContext(&#x27;2d&#x27;);
                    context.drawImage(image, 0, 0);
                    v.contents = canvas;
                    v.version = +new Date();
                    if (typeof v.loaded === &#x27;function&#x27;) {
                        v.loaded();
                    } else {
                        v.loaded = true;
                    }
                };
            }
            image.src = model.attributes.image;
        }
        record();
        return v;
    case &#x27;sound&#x27;:
        audio = new Audio();
        audio.src = model.attributes.sound;
        v = new Sound(audio, model.attributes.name);
        if (Object.prototype.hasOwnProperty.call(
                model.attributes,
                &#x27;mediaID&#x27;
            )) {
            myself.mediaDict[model.attributes.mediaID] = v;
        }
        return v;
    }
    return undefined;
};

SnapSerializer.prototype.loadColor = function (colorString) {
    // private
    var c = (colorString || &#x27;&#x27;).split(&#x27;,&#x27;);
    return new Color(
        parseFloat(c[0]),
        parseFloat(c[1]),
        parseFloat(c[2]),
        parseFloat(c[3])
    );
};

SnapSerializer.prototype.openProject = function (project, ide) {
    var stage = ide.stage,
        sprites = [],
        sprite;
    if (!project || !project.stage) {
        return;
    }
    ide.projectName = project.name;
    ide.projectNotes = project.notes || &#x27;&#x27;;
    if (ide.globalVariables) {
        ide.globalVariables = project.globalVariables;
    }
    if (stage) {
        stage.destroy();
    }
    ide.add(project.stage);
    ide.stage = project.stage;
    sprites = ide.stage.children.filter(function (child) {
        return child instanceof SpriteMorph;
    });
    sprites.sort(function (x, y) {
        return x.idx - y.idx;
    });

    ide.sprites = new List(sprites);
    sprite = sprites[0] || project.stage;

    if (sizeOf(this.mediaDict) &gt; 0) {
        ide.hasChangedMedia = false;
        this.mediaDict = {};
    } else {
        ide.hasChangedMedia = true;
    }
    project.stage.drawNew();
    ide.createCorral();
    ide.selectSprite(sprite);
    ide.fixLayout();
    ide.world().keyboardReceiver = project.stage;
};

// SnapSerializer XML-representation of objects:

// Generics

Array.prototype.toXML = function (serializer) {
    return this.reduce(function (xml, item) {
        return xml + serializer.store(item);
    }, &#x27;&#x27;);
};

// Sprites

StageMorph.prototype.toXML = function (serializer) {
    var thumbnail = this.thumbnail(SnapSerializer.prototype.thumbnailSize),
        thumbdata,
        ide = this.parentThatIsA(IDE_Morph);

    // catch cross-origin tainting exception when using SVG costumes
    try {
        thumbdata = thumbnail.toDataURL(&#x27;image/png&#x27;);
    } catch (error) {
        thumbdata = null;
    }

    function code(key) {
        var str = &#x27;&#x27;;
        Object.keys(StageMorph.prototype[key]).forEach(
            function (selector) {
                str += (
                    &#x27;&lt;&#x27; + selector + &#x27;&gt;&#x27; +
                        XML_Element.prototype.escape(
                            StageMorph.prototype[key][selector]
                        ) +
                        &#x27;&lt;/&#x27; + selector + &#x27;&gt;&#x27;
                );
            }
        );
        return str;
    }

    this.removeAllClones();
    return serializer.format(
        &#x27;&lt;project name=&quot;@&quot; app=&quot;@&quot; version=&quot;@&quot;&gt;&#x27; +
            &#x27;&lt;notes&gt;$&lt;/notes&gt;&#x27; +
            &#x27;&lt;thumbnail&gt;$&lt;/thumbnail&gt;&#x27; +
            &#x27;&lt;stage name=&quot;@&quot; costume=&quot;@&quot; tempo=&quot;@&quot; threadsafe=&quot;@&quot; &#x27; +
            &#x27;codify=&quot;@&quot; &#x27; +
            &#x27;scheduled=&quot;@&quot; ~&gt;&#x27; +
            &#x27;&lt;pentrails&gt;$&lt;/pentrails&gt;&#x27; +
            &#x27;&lt;costumes&gt;%&lt;/costumes&gt;&#x27; +
            &#x27;&lt;sounds&gt;%&lt;/sounds&gt;&#x27; +
            &#x27;&lt;variables&gt;%&lt;/variables&gt;&#x27; +
            &#x27;&lt;blocks&gt;%&lt;/blocks&gt;&#x27; +
            &#x27;&lt;scripts&gt;%&lt;/scripts&gt;&lt;sprites&gt;%&lt;/sprites&gt;&#x27; +
            &#x27;&lt;/stage&gt;&#x27; +
            &#x27;&lt;hidden&gt;$&lt;/hidden&gt;&#x27; +
            &#x27;&lt;headers&gt;%&lt;/headers&gt;&#x27; +
            &#x27;&lt;code&gt;%&lt;/code&gt;&#x27; +
            &#x27;&lt;blocks&gt;%&lt;/blocks&gt;&#x27; +
            &#x27;&lt;variables&gt;%&lt;/variables&gt;&#x27; +
            &#x27;&lt;/project&gt;&#x27;,
        (ide &amp;&amp; ide.projectName) ? ide.projectName : &#x27;Untitled&#x27;,
        serializer.app,
        serializer.version,
        (ide &amp;&amp; ide.projectNotes) ? ide.projectNotes : &#x27;&#x27;,
        thumbdata,
        this.name,
        this.getCostumeIdx(),
        this.getTempo(),
        this.isThreadSafe,
        this.enableCodeMapping,
        StageMorph.prototype.frameRate !== 0,
        this.trailsCanvas.toDataURL(&#x27;image/png&#x27;),
        serializer.store(this.costumes, this.name + &#x27;_cst&#x27;),
        serializer.store(this.sounds, this.name + &#x27;_snd&#x27;),
        serializer.store(this.variables),
        serializer.store(this.customBlocks),
        serializer.store(this.scripts),
        serializer.store(this.children),
        Object.keys(StageMorph.prototype.hiddenPrimitives).reduce(
                function (a, b) {return a + &#x27; &#x27; + b; },
                &#x27;&#x27;
            ),
        code(&#x27;codeHeaders&#x27;),
        code(&#x27;codeMappings&#x27;),
        serializer.store(this.globalBlocks),
        (ide &amp;&amp; ide.globalVariables) ?
                    serializer.store(ide.globalVariables) : &#x27;&#x27;
    );
};

SpriteMorph.prototype.toXML = function (serializer) {
    var stage = this.parentThatIsA(StageMorph),
        ide = stage ? stage.parentThatIsA(IDE_Morph) : null,
        idx = ide ? ide.sprites.asArray().indexOf(this) + 1 : 0;
    return serializer.format(
        &#x27;&lt;sprite name=&quot;@&quot; idx=&quot;@&quot; x=&quot;@&quot; y=&quot;@&quot;&#x27; +
            &#x27; heading=&quot;@&quot;&#x27; +
            &#x27; scale=&quot;@&quot;&#x27; +
            &#x27; rotation=&quot;@&quot;&#x27; +
            &#x27; draggable=&quot;@&quot;&#x27; +
            &#x27;%&#x27; +
            &#x27; costume=&quot;@&quot; color=&quot;@,@,@&quot; pen=&quot;@&quot; ~&gt;&#x27; +
            &#x27;%&#x27; + // nesting info
            &#x27;&lt;costumes&gt;%&lt;/costumes&gt;&#x27; +
            &#x27;&lt;sounds&gt;%&lt;/sounds&gt;&#x27; +
            &#x27;&lt;variables&gt;%&lt;/variables&gt;&#x27; +
            &#x27;&lt;blocks&gt;%&lt;/blocks&gt;&#x27; +
            &#x27;&lt;scripts&gt;%&lt;/scripts&gt;&#x27; +
            &#x27;&lt;/sprite&gt;&#x27;,
        this.name,
        idx,
        this.xPosition(),
        this.yPosition(),
        this.heading,
        this.scale,
        this.rotationStyle,
        this.isDraggable,
        this.isVisible ? &#x27;&#x27; : &#x27; hidden=&quot;true&quot;&#x27;,
        this.getCostumeIdx(),
        this.color.r,
        this.color.g,
        this.color.b,
        this.penPoint,

        // nesting info
        this.anchor
            ? &#x27;&lt;nest anchor=&quot;&#x27; +
                    this.anchor.name +
                    &#x27;&quot; synch=&quot;&#x27;
                    + this.rotatesWithAnchor
                    + (this.scale === this.nestingScale ? &#x27;&#x27; :
                            &#x27;&quot;&#x27;
                            + &#x27; scale=&quot;&#x27;
                            + this.nestingScale)

                    + &#x27;&quot;/&gt;&#x27;
            : &#x27;&#x27;,

        serializer.store(this.costumes, this.name + &#x27;_cst&#x27;),
        serializer.store(this.sounds, this.name + &#x27;_snd&#x27;),
        serializer.store(this.variables),
        !this.customBlocks ?
                    &#x27;&#x27; : serializer.store(this.customBlocks),
        serializer.store(this.scripts)
    );
};

Costume.prototype[XML_Serializer.prototype.mediaDetectionProperty] = true;

Costume.prototype.toXML = function (serializer) {
    return serializer.format(
        &#x27;&lt;costume name=&quot;@&quot; center-x=&quot;@&quot; center-y=&quot;@&quot; image=&quot;@&quot; ~/&gt;&#x27;,
        this.name,
        this.rotationCenter.x,
        this.rotationCenter.y,
        this instanceof SVG_Costume ?
                this.contents.src : this.contents.toDataURL(&#x27;image/png&#x27;)
    );
};

Sound.prototype[XML_Serializer.prototype.mediaDetectionProperty] = true;

Sound.prototype.toXML = function (serializer) {
    return serializer.format(
        &#x27;&lt;sound name=&quot;@&quot; sound=&quot;@&quot; ~/&gt;&#x27;,
        this.name,
        this.toDataURL()
    );
};

VariableFrame.prototype.toXML = function (serializer) {
    var myself = this;
    return Object.keys(this.vars).reduce(function (vars, v) {
        var val = myself.vars[v],
            dta;
        if (val === undefined || val === null) {
            dta = serializer.format(&#x27;&lt;variable name=&quot;@&quot;/&gt;&#x27;, v);
        } else {
            dta = serializer.format(
                &#x27;&lt;variable name=&quot;@&quot;&gt;%&lt;/variable&gt;&#x27;,
                v,
                typeof val === &#x27;object&#x27; ? serializer.store(val)
                        : typeof val === &#x27;boolean&#x27; ?
                                serializer.format(&#x27;&lt;bool&gt;$&lt;/bool&gt;&#x27;, val)
                                : serializer.format(&#x27;&lt;l&gt;$&lt;/l&gt;&#x27;, val)
            );
        }
        return vars + dta;
    }, &#x27;&#x27;);
};

// Watchers

WatcherMorph.prototype.toXML = function (serializer) {
    var isVar = this.target instanceof VariableFrame,
        isList = this.currentValue instanceof List,
        color = this.readoutColor,
        position = this.parent ?
                this.topLeft().subtract(this.parent.topLeft())
                : this.topLeft();

    return serializer.format(
        &#x27;&lt;watcher% % style=&quot;@&quot;% x=&quot;@&quot; y=&quot;@&quot; color=&quot;@,@,@&quot;%%/&gt;&#x27;,
        (isVar &amp;&amp; this.target.owner) || (!isVar &amp;&amp; this.target) ?
                    serializer.format(&#x27; scope=&quot;@&quot;&#x27;,
                        isVar ? this.target.owner.name : this.target.name)
                            : &#x27;&#x27;,
        serializer.format(isVar ? &#x27;var=&quot;@&quot;&#x27; : &#x27;s=&quot;@&quot;&#x27;, this.getter),
        this.style,
        isVar &amp;&amp; this.style === &#x27;slider&#x27; ? serializer.format(
                &#x27; min=&quot;@&quot; max=&quot;@&quot;&#x27;,
                this.sliderMorph.start,
                this.sliderMorph.stop
            ) : &#x27;&#x27;,
        position.x,
        position.y,
        color.r,
        color.g,
        color.b,
        !isList ? &#x27;&#x27;
                : serializer.format(
                &#x27; extX=&quot;@&quot; extY=&quot;@&quot;&#x27;,
                this.cellMorph.contentsMorph.width(),
                this.cellMorph.contentsMorph.height()
            ),
        this.isVisible ? &#x27;&#x27; : &#x27; hidden=&quot;true&quot;&#x27;
    );
};

// Scripts

ScriptsMorph.prototype.toXML = function (serializer) {
    return this.children.reduce(function (xml, child) {
        if (child instanceof BlockMorph) {
            return xml + child.toScriptXML(serializer, true);
        }
        if (child instanceof CommentMorph &amp;&amp; !child.block) { // unattached
            return xml + child.toXML(serializer);
        }
        return xml;
    }, &#x27;&#x27;);
};

BlockMorph.prototype.toXML = BlockMorph.prototype.toScriptXML = function (
    serializer,
    savePosition
) {
    var position,
        xml,
        scale = SyntaxElementMorph.prototype.scale,
        block = this;

    // determine my position
    if (this.parent) {
        position = this.topLeft().subtract(this.parent.topLeft());
    } else {
        position = this.topLeft();
    }

    // save my position to xml
    if (savePosition) {
        xml = serializer.format(
            &#x27;&lt;script x=&quot;@&quot; y=&quot;@&quot;&gt;&#x27;,
            position.x / scale,
            position.y / scale
        );
    } else {
        xml = &#x27;&lt;script&gt;&#x27;;
    }

    // recursively add my next blocks to xml
    do {
        xml += block.toBlockXML(serializer);
        block = block.nextBlock();
    } while (block);
    xml += &#x27;&lt;/script&gt;&#x27;;
    return xml;
};

BlockMorph.prototype.toBlockXML = function (serializer) {
    return serializer.format(
        &#x27;&lt;block s=&quot;@&quot;&gt;%%&lt;/block&gt;&#x27;,
        this.selector,
        serializer.store(this.inputs()),
        this.comment ? this.comment.toXML(serializer) : &#x27;&#x27;
    );
};

ReporterBlockMorph.prototype.toXML = function (serializer) {
    return this.selector === &#x27;reportGetVar&#x27; ? serializer.format(
        &#x27;&lt;block var=&quot;@&quot;/&gt;&#x27;,
        this.blockSpec
    ) : this.toBlockXML(serializer);
};

ReporterBlockMorph.prototype.toScriptXML = function (
    serializer,
    savePosition
) {
    var position,
        scale = SyntaxElementMorph.prototype.scale;

    // determine my save-position
    if (this.parent) {
        position = this.topLeft().subtract(this.parent.topLeft());
    } else {
        position = this.topLeft();
    }

    if (savePosition) {
        return serializer.format(
            &#x27;&lt;script x=&quot;@&quot; y=&quot;@&quot;&gt;%&lt;/script&gt;&#x27;,
            position.x / scale,
            position.y / scale,
            this.toXML(serializer)
        );
    }
    return serializer.format(&#x27;&lt;script&gt;%&lt;/script&gt;&#x27;, this.toXML(serializer));
};

CustomCommandBlockMorph.prototype.toBlockXML = function (serializer) {
    var scope = this.definition.isGlobal ? undefined
        : this.definition.receiver.name;
    return serializer.format(
        &#x27;&lt;custom-block s=&quot;@&quot;%&gt;%%%&lt;/custom-block&gt;&#x27;,
        this.blockSpec,
        this.definition.isGlobal ?
                &#x27;&#x27; : serializer.format(&#x27; scope=&quot;@&quot;&#x27;, scope),
        serializer.store(this.inputs()),
        this.comment ? this.comment.toXML(serializer) : &#x27;&#x27;,
        scope &amp;&amp; !this.definition.receiver[serializer.idProperty] ?
                &#x27;&lt;receiver&gt;&#x27; +
                    serializer.store(this.definition.receiver) +
                    &#x27;&lt;/receiver&gt;&#x27;
                        : &#x27;&#x27;
    );
};

CustomReporterBlockMorph.prototype.toBlockXML
    = CustomCommandBlockMorph.prototype.toBlockXML;

CustomBlockDefinition.prototype.toXML = function (serializer) {
    var myself = this;

    function encodeScripts(array) {
        return array.reduce(function (xml, element) {
            if (element instanceof BlockMorph) {
                return xml + element.toScriptXML(serializer, true);
            }
            if (element instanceof CommentMorph &amp;&amp; !element.block) {
                return xml + element.toXML(serializer);
            }
            return xml;
        }, &#x27;&#x27;);
    }

    return serializer.format(
        &#x27;&lt;block-definition s=&quot;@&quot; type=&quot;@&quot; category=&quot;@&quot;&gt;&#x27; +
            &#x27;%&#x27; +
            &#x27;&lt;header&gt;@&lt;/header&gt;&#x27; +
            &#x27;&lt;code&gt;@&lt;/code&gt;&#x27; +
            &#x27;&lt;inputs&gt;%&lt;/inputs&gt;%%&#x27; +
            &#x27;&lt;/block-definition&gt;&#x27;,
        this.spec,
        this.type,
        this.category || &#x27;other&#x27;,
        this.comment ? this.comment.toXML(serializer) : &#x27;&#x27;,
        this.codeHeader || &#x27;&#x27;,
        this.codeMapping || &#x27;&#x27;,
        Object.keys(this.declarations).reduce(function (xml, decl) {
                return xml + serializer.format(
                    &#x27;&lt;input type=&quot;@&quot;$&gt;$%&lt;/input&gt;&#x27;,
                    myself.declarations[decl][0],
                    myself.declarations[decl][3] ?
                            &#x27; readonly=&quot;true&quot;&#x27; : &#x27;&#x27;,
                    myself.declarations[decl][1],
                    myself.declarations[decl][2] ?
                            &#x27;&lt;options&gt;&#x27; + myself.declarations[decl][2] +
                                &#x27;&lt;/options&gt;&#x27;
                                : &#x27;&#x27;
                );
            }, &#x27;&#x27;),
        this.body ? serializer.store(this.body.expression) : &#x27;&#x27;,
        this.scripts.length &gt; 0 ?
                    &#x27;&lt;scripts&gt;&#x27; + encodeScripts(this.scripts) + &#x27;&lt;/scripts&gt;&#x27;
                        : &#x27;&#x27;
    );
};

// Scripts - Inputs

ArgMorph.prototype.toXML = function () {
    return &#x27;&lt;l/&gt;&#x27;; // empty by default
};

InputSlotMorph.prototype.toXML = function (serializer) {
    if (this.constant) {
        return serializer.format(
            &#x27;&lt;l&gt;&lt;option&gt;$&lt;/option&gt;&lt;/l&gt;&#x27;,
            this.constant
        );
    }
    return serializer.format(&#x27;&lt;l&gt;$&lt;/l&gt;&#x27;, this.contents().text);
};

TemplateSlotMorph.prototype.toXML = function (serializer) {
    return serializer.format(&#x27;&lt;l&gt;$&lt;/l&gt;&#x27;, this.contents());
};

CommandSlotMorph.prototype.toXML = function (serializer) {
    var block = this.children[0];
    if (block instanceof BlockMorph) {
        if (block instanceof ReporterBlockMorph) {
            return serializer.format(
                &#x27;&lt;autolambda&gt;%&lt;/autolambda&gt;&#x27;,
                serializer.store(block)
            );
        }
        return serializer.store(block);
    }
    return &#x27;&lt;script&gt;&lt;/script&gt;&#x27;;
};

FunctionSlotMorph.prototype.toXML = CommandSlotMorph.prototype.toXML;

MultiArgMorph.prototype.toXML = function (serializer) {
    return serializer.format(
        &#x27;&lt;list&gt;%&lt;/list&gt;&#x27;,
        serializer.store(this.inputs())
    );
};

ArgLabelMorph.prototype.toXML = function (serializer) {
    return serializer.format(
        &#x27;%&#x27;,
        serializer.store(this.inputs()[0])
    );
};

ColorSlotMorph.prototype.toXML = function (serializer) {
    return serializer.format(
        &#x27;&lt;color&gt;$,$,$,$&lt;/color&gt;&#x27;,
        this.color.r,
        this.color.g,
        this.color.b,
        this.color.a
    );
};

// Values

List.prototype.toXML = function (serializer, mediaContext) {
    // mediaContext is an optional name-stub
    // when collecting media into a separate module
    var xml, item;
    if (this.isLinked) {
        xml = &#x27;&lt;list linked=&quot;linked&quot; ~&gt;&#x27;;
        item = this;
        do {
            xml += serializer.format(
                &#x27;&lt;item&gt;%&lt;/item&gt;&#x27;,
                serializer.store(item.first)
            );
            item = item.rest;
        } while (item !== undefined &amp;&amp; (item !== null));
        return xml + &#x27;&lt;/list&gt;&#x27;;
    }
    return serializer.format(
        &#x27;&lt;list ~&gt;%&lt;/list&gt;&#x27;,
        this.contents.reduce(function (xml, item) {
            return xml + serializer.format(
                &#x27;&lt;item&gt;%&lt;/item&gt;&#x27;,
                typeof item === &#x27;object&#x27; ?
                        serializer.store(item, mediaContext)
                        : typeof item === &#x27;boolean&#x27; ?
                                serializer.format(&#x27;&lt;bool&gt;$&lt;/bool&gt;&#x27;, item)
                                : serializer.format(&#x27;&lt;l&gt;$&lt;/l&gt;&#x27;, item)
            );
        }, &#x27;&#x27;)
    );
};


Context.prototype.toXML = function (serializer) {
    if (this.isContinuation) { // continuations are transient in Snap!
        return &#x27;&#x27;;
    }
    return serializer.format(
        &#x27;&lt;context% ~&gt;&lt;inputs&gt;%&lt;/inputs&gt;&lt;variables&gt;%&lt;/variables&gt;&#x27; +
            &#x27;%&lt;receiver&gt;%&lt;/receiver&gt;%&lt;/context&gt;&#x27;,
        this.isLambda ? &#x27; lambda=&quot;lambda&quot;&#x27; : &#x27;&#x27;,
        this.inputs.reduce(
                function (xml, input) {
                    return xml + serializer.format(&#x27;&lt;input&gt;$&lt;/input&gt;&#x27;, input);
                },
                &#x27;&#x27;
            ),
        this.variables ? serializer.store(this.variables) : &#x27;&#x27;,
        this.expression ? serializer.store(this.expression) : &#x27;&#x27;,
        this.receiver ? serializer.store(this.receiver) : &#x27;&#x27;,
        this.outerContext ? serializer.store(this.outerContext) : &#x27;&#x27;
    );
};

// Comments

CommentMorph.prototype.toXML = function (serializer) {
    var position,
        scale = SyntaxElementMorph.prototype.scale;

    if (this.block) { // attached to a block
        return serializer.format(
            &#x27;&lt;comment w=&quot;@&quot; collapsed=&quot;@&quot;&gt;%&lt;/comment&gt;&#x27;,
            this.textWidth() / scale,
            this.isCollapsed,
            serializer.escape(this.text())
        );
    }

    // free-floating, determine my save-position
    if (this.parent) {
        position = this.topLeft().subtract(this.parent.topLeft());
    } else {
        position = this.topLeft();
    }
    return serializer.format(
        &#x27;&lt;comment x=&quot;@&quot; y=&quot;@&quot; w=&quot;@&quot; collapsed=&quot;@&quot;&gt;%&lt;/comment&gt;&#x27;,
        position.x / scale,
        position.y / scale,
        this.textWidth() / scale,
        this.isCollapsed,
        serializer.escape(this.text())
    );
};

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
